import { flatMorph } from "./flatMorph.js";
export const entriesOf = (o) => Object.entries(o);
export const fromEntries = (entries) => Object.fromEntries(entries);
export const keysOf = (o) => Object.keys(o);
export const isKeyOf = (k, o) => k in o;
export const hasKey = (o, k) => k in o;
// must be defined this way to avoid https://github.com/microsoft/TypeScript/issues/55049
export const hasDefinedKey = (o, k) => o[k] !== undefined;
export const InnerDynamicBase = class {
    constructor(properties) {
        Object.assign(this, properties);
    }
};
/** @ts-expect-error (needed to extend `t`, but safe given ShallowClone's implementation) **/
export class DynamicBase extends InnerDynamicBase {
}
export const NoopBase = class {
};
/** @ts-expect-error (see DynamicBase) **/
export class CastableBase extends NoopBase {
}
export const splitByKeys = (o, leftKeys) => {
    const l = {};
    const r = {};
    let k;
    for (k in o) {
        if (k in leftKeys)
            l[k] = o[k];
        else
            r[k] = o[k];
    }
    return [l, r];
};
export const pick = (o, keys) => splitByKeys(o, keys)[0];
export const omit = (o, keys) => splitByKeys(o, keys)[1];
export const isEmptyObject = (o) => Object.keys(o).length === 0;
export const stringAndSymbolicEntriesOf = (o) => [
    ...Object.entries(o),
    ...Object.getOwnPropertySymbols(o).map(k => [k, o[k]])
];
/** Like Object.assign, but it will preserve getters instead of evaluating them. */
export const defineProperties = (base, merged) => 
// declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049
Object.defineProperties(base, Object.getOwnPropertyDescriptors(merged));
export const invert = (t) => flatMorph(t, (k, v) => [v, k]);
export const unset = Symbol("represents an uninitialized value");
