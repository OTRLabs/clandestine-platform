import { domainOf } from "./domain.js";
import { isKeyOf } from "./records.js";
// Built-in object constructors based on a subset of:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
export const builtinConstructors = {
    Array,
    Date,
    Error,
    Function,
    Map,
    RegExp,
    Set,
    String,
    Number,
    Boolean,
    WeakMap,
    WeakSet,
    Promise
};
export const objectKindOf = (data) => {
    let prototype = Object.getPrototypeOf(data);
    while (prototype?.constructor &&
        (!isKeyOf(prototype.constructor.name, builtinConstructors) ||
            !(data instanceof builtinConstructors[prototype.constructor.name])))
        prototype = Object.getPrototypeOf(prototype);
    const name = prototype?.constructor?.name;
    if (name === undefined || name === "Object")
        return undefined;
    return name;
};
export const objectKindOrDomainOf = (data) => (typeof data === "object" && data !== null ?
    objectKindOf(data) ?? "object"
    : domainOf(data));
export const hasObjectKind = (data, kind) => objectKindOf(data) === kind;
export const isArray = (data) => Array.isArray(data);
/** Each defaultObjectKind's completion for the phrase "must be _____" */
export const objectKindDescriptions = {
    Array: "an array",
    Function: "a function",
    Date: "a Date",
    RegExp: "a RegExp",
    Error: "an Error",
    Map: "a Map",
    Set: "a Set",
    String: "a String object",
    Number: "a Number object",
    Boolean: "a Boolean object",
    Promise: "a Promise",
    WeakMap: "a WeakMap",
    WeakSet: "a WeakSet"
};
// this will only return an object kind if it's the root constructor
// example TypeError would return undefined not 'Error'
export const getExactBuiltinConstructorName = (ctor) => {
    const constructorName = Object(ctor).name ?? null;
    return (constructorName &&
        isKeyOf(constructorName, builtinConstructors) &&
        builtinConstructors[constructorName] === ctor) ?
        constructorName
        : null;
};
/**
 * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.
 *
 * @param {object} o - The object to find the ancestors of.
 * @returns {Function[]} An array of constructors for all ancestors of the object.
 */
export const ancestorsOf = (o) => {
    let proto = Object.getPrototypeOf(o);
    const result = [];
    while (proto !== null) {
        result.push(proto.constructor);
        proto = Object.getPrototypeOf(proto);
    }
    return result;
};
/** Mimics output of TS's keyof operator at runtime */
export const prototypeKeysOf = (value) => {
    const result = [];
    let curr = value;
    while (curr !== Object.prototype && curr !== null && curr !== undefined) {
        for (const k of Object.getOwnPropertyNames(curr))
            if (k !== "constructor" && !result.includes(k))
                result.push(k);
        for (const symbol of Object.getOwnPropertySymbols(curr))
            if (!result.includes(symbol))
                result.push(symbol);
        curr = Object.getPrototypeOf(curr);
    }
    return result;
};
const baseKeysByDomain = {
    bigint: prototypeKeysOf(0n),
    boolean: prototypeKeysOf(false),
    null: [],
    number: prototypeKeysOf(0),
    // TS doesn't include the Object prototype in keyof, so keyof object is never
    object: [],
    string: prototypeKeysOf(""),
    symbol: prototypeKeysOf(Symbol()),
    undefined: []
};
export const getBaseDomainKeys = (domain) => [...baseKeysByDomain[domain]];
export const constructorExtends = (ctor, base) => {
    let current = ctor.prototype;
    while (current !== null) {
        if (current === base.prototype)
            return true;
        current = Object.getPrototypeOf(current);
    }
    return false;
};
