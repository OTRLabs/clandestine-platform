import { envHasCsp, flatMorph } from "@ark/util";
import { PredicateNode, predicateImplementation } from "./predicate.js";
import { DivisorNode, divisorImplementation } from "./refinements/divisor.js";
import { boundClassesByKind, boundImplementationsByKind } from "./refinements/kinds.js";
import { PatternNode, patternImplementation } from "./refinements/pattern.js";
import { AliasNode, aliasImplementation } from "./roots/alias.js";
import { DomainNode, domainImplementation } from "./roots/domain.js";
import { IntersectionNode, intersectionImplementation } from "./roots/intersection.js";
import { MorphNode, morphImplementation } from "./roots/morph.js";
import { ProtoNode, protoImplementation } from "./roots/proto.js";
import { UnionNode, unionImplementation } from "./roots/union.js";
import { UnitNode, unitImplementation } from "./roots/unit.js";
import { IndexNode, indexImplementation } from "./structure/indexed.js";
import { OptionalNode, optionalImplementation } from "./structure/optional.js";
import { RequiredNode, requiredImplementation } from "./structure/required.js";
import { SequenceNode, sequenceImplementation } from "./structure/sequence.js";
import { StructureNode, structureImplementation } from "./structure/structure.js";
export const nodeImplementationsByKind = {
    ...boundImplementationsByKind,
    alias: aliasImplementation,
    domain: domainImplementation,
    unit: unitImplementation,
    proto: protoImplementation,
    union: unionImplementation,
    morph: morphImplementation,
    intersection: intersectionImplementation,
    divisor: divisorImplementation,
    pattern: patternImplementation,
    predicate: predicateImplementation,
    required: requiredImplementation,
    optional: optionalImplementation,
    index: indexImplementation,
    sequence: sequenceImplementation,
    structure: structureImplementation
};
$ark.defaultConfig = Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [
    kind,
    implementation.defaults
]), {
    jitless: envHasCsp(),
    intrinsic: false,
    prereducedAliases: false
});
export const nodeClassesByKind = {
    ...boundClassesByKind,
    alias: AliasNode,
    domain: DomainNode,
    unit: UnitNode,
    proto: ProtoNode,
    union: UnionNode,
    morph: MorphNode,
    intersection: IntersectionNode,
    divisor: DivisorNode,
    pattern: PatternNode,
    predicate: PredicateNode,
    required: RequiredNode,
    optional: OptionalNode,
    index: IndexNode,
    sequence: SequenceNode,
    structure: StructureNode
};
