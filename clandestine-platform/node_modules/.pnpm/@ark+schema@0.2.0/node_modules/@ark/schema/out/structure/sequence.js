var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { append, cached, throwInternalError, throwParseError } from "@ark/util";
import { BaseConstraint } from "../constraint.js";
import { appendUniqueFlatRefs, flatRef } from "../node.js";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { intersectNodes } from "../shared/intersections.js";
const fixedSequenceKeySchemaDefinition = {
    child: true,
    parse: (schema, ctx) => schema.length === 0 ?
        // empty affixes are omitted. an empty array should therefore
        // be specified as `{ proto: Array, length: 0 }`
        undefined
        : schema.map(element => ctx.$.schema(element))
};
export const sequenceImplementation = implementNode({
    kind: "sequence",
    hasAssociatedError: false,
    collapsibleKey: "variadic",
    keys: {
        prefix: fixedSequenceKeySchemaDefinition,
        optionals: fixedSequenceKeySchemaDefinition,
        variadic: {
            child: true,
            parse: (schema, ctx) => ctx.$.schema(schema, ctx)
        },
        minVariadicLength: {
            // minVariadicLength is reflected in the id of this node,
            // but not its IntersectionNode parent since it is superceded by the minLength
            // node it implies
            parse: min => (min === 0 ? undefined : min)
        },
        postfix: fixedSequenceKeySchemaDefinition
    },
    normalize: schema => {
        if (typeof schema === "string")
            return { variadic: schema };
        if ("variadic" in schema ||
            "prefix" in schema ||
            "optionals" in schema ||
            "postfix" in schema ||
            "minVariadicLength" in schema) {
            if (schema.postfix?.length) {
                if (!schema.variadic)
                    return throwParseError(postfixWithoutVariadicMessage);
                if (schema.optionals?.length)
                    return throwParseError(postfixFollowingOptionalMessage);
            }
            if (schema.minVariadicLength && !schema.variadic) {
                return throwParseError("minVariadicLength may not be specified without a variadic element");
            }
            return schema;
        }
        return { variadic: schema };
    },
    reduce: (raw, $) => {
        let minVariadicLength = raw.minVariadicLength ?? 0;
        const prefix = raw.prefix?.slice() ?? [];
        const optional = raw.optionals?.slice() ?? [];
        const postfix = raw.postfix?.slice() ?? [];
        if (raw.variadic) {
            // optional elements equivalent to the variadic parameter are redundant
            while (optional.at(-1)?.equals(raw.variadic))
                optional.pop();
            if (optional.length === 0) {
                // If there are no optional, normalize prefix
                // elements adjacent and equivalent to variadic:
                // 		{ variadic: number, prefix: [string, number] }
                // reduces to:
                // 		{ variadic: number, prefix: [string], minVariadicLength: 1 }
                while (prefix.at(-1)?.equals(raw.variadic)) {
                    prefix.pop();
                    minVariadicLength++;
                }
            }
            // Normalize postfix elements adjacent and equivalent to variadic:
            // 		{ variadic: number, postfix: [number, number, 5] }
            // reduces to:
            // 		{ variadic: number, postfix: [5], minVariadicLength: 2 }
            while (postfix[0]?.equals(raw.variadic)) {
                postfix.shift();
                minVariadicLength++;
            }
        }
        else if (optional.length === 0) {
            // if there's no variadic or optional parameters,
            // postfix can just be appended to prefix
            prefix.push(...postfix.splice(0));
        }
        if (
        // if any variadic adjacent elements were moved to minVariadicLength
        minVariadicLength !== raw.minVariadicLength ||
            // or any postfix elements were moved to prefix
            (raw.prefix && raw.prefix.length !== prefix.length)) {
            // reparse the reduced def
            return $.node("sequence", {
                ...raw,
                // empty lists will be omitted during parsing
                prefix,
                postfix,
                optionals: optional,
                minVariadicLength
            }, { prereduced: true });
        }
    },
    defaults: {
        description: node => {
            if (node.isVariadicOnly)
                return `${node.variadic.nestableExpression}[]`;
            const innerDescription = node.tuple
                .map(element => element.kind === "optionals" ? `${element.node.nestableExpression}?`
                : element.kind === "variadic" ?
                    `...${element.node.nestableExpression}[]`
                    : element.node.expression)
                .join(", ");
            return `[${innerDescription}]`;
        }
    },
    intersections: {
        sequence: (l, r, ctx) => {
            const rootState = _intersectSequences({
                l: l.tuple,
                r: r.tuple,
                disjoint: new Disjoint(),
                result: [],
                fixedVariants: [],
                ctx
            });
            const viableBranches = rootState.disjoint.length === 0 ?
                [rootState, ...rootState.fixedVariants]
                : rootState.fixedVariants;
            return (viableBranches.length === 0 ? rootState.disjoint
                : viableBranches.length === 1 ?
                    ctx.$.node("sequence", sequenceTupleToInner(viableBranches[0].result))
                    : ctx.$.node("union", viableBranches.map(state => ({
                        proto: Array,
                        sequence: sequenceTupleToInner(state.result)
                    }))));
        }
        // exactLength, minLength, and maxLength don't need to be defined
        // here since impliedSiblings guarantees they will be added
        // directly to the IntersectionNode parent of the SequenceNode
        // they exist on
    }
});
let SequenceNode = (() => {
    let _classSuper = BaseConstraint;
    let _instanceExtraInitializers = [];
    let _get_element_decorators;
    return class SequenceNode extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _get_element_decorators = [cached];
            __esDecorate(this, null, _get_element_decorators, { kind: "getter", name: "element", static: false, private: false, access: { has: obj => "element" in obj, get: obj => obj.element }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), $ark.intrinsic.Array);
        prefix = this.inner.prefix ?? [];
        optionals = this.inner.optionals ?? [];
        prevariadic = [...this.prefix, ...this.optionals];
        postfix = this.inner.postfix ?? [];
        variadicOrPostfix = this.variadic ? [this.variadic, ...this.postfix] : this.postfix;
        isVariadicOnly = this.prevariadic.length + this.postfix.length === 0;
        minVariadicLength = this.inner.minVariadicLength ?? 0;
        minLength = this.prefix.length + this.minVariadicLength + this.postfix.length;
        minLengthNode = this.minLength === 0 ? null : this.$.node("minLength", this.minLength);
        maxLength = this.variadic ? null : this.minLength + this.optionals.length;
        maxLengthNode = this.maxLength === null ? null : this.$.node("maxLength", this.maxLength);
        impliedSiblings = this.minLengthNode ?
            this.maxLengthNode ?
                [this.minLengthNode, this.maxLengthNode]
                : [this.minLengthNode]
            : this.maxLengthNode ? [this.maxLengthNode]
                : [];
        childAtIndex(data, index) {
            if (index < this.prevariadic.length)
                return this.prevariadic[index];
            const firstPostfixIndex = data.length - this.postfix.length;
            if (index >= firstPostfixIndex)
                return this.postfix[index - firstPostfixIndex];
            return (this.variadic ??
                throwInternalError(`Unexpected attempt to access index ${index} on ${this}`));
        }
        // minLength/maxLength should be checked by Intersection before either traversal
        traverseAllows = (data, ctx) => {
            for (let i = 0; i < data.length; i++)
                if (!this.childAtIndex(data, i).traverseAllows(data[i], ctx))
                    return false;
            return true;
        };
        traverseApply = (data, ctx) => {
            for (let i = 0; i < data.length; i++) {
                ctx.path.push(i);
                this.childAtIndex(data, i).traverseApply(data[i], ctx);
                ctx.path.pop();
            }
        };
        get flatRefs() {
            const refs = [];
            appendUniqueFlatRefs(refs, this.prevariadic.flatMap((element, i) => append(element.flatRefs.map(ref => flatRef([`${i}`, ...ref.path], ref.node)), flatRef([`${i}`], element))));
            appendUniqueFlatRefs(refs, this.variadicOrPostfix.flatMap(element => 
            // a postfix index can't be directly represented as a type
            // key, so we just use the same matcher for variadic
            append(element.flatRefs.map(ref => flatRef([$ark.intrinsic.nonNegativeIntegerString, ...ref.path], ref.node)), flatRef([$ark.intrinsic.nonNegativeIntegerString], element))));
            return refs;
        }
        get element() {
            return this.$.node("union", this.children);
        }
        // minLength/maxLength compilation should be handled by Intersection
        compile(js) {
            this.prefix.forEach((node, i) => js.traverseKey(`${i}`, `data[${i}]`, node));
            this.optionals.forEach((node, i) => {
                const dataIndex = `${i + this.prefix.length}`;
                js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === "Allows" ? js.return(true) : js.return());
                js.traverseKey(dataIndex, `data[${dataIndex}]`, node);
            });
            if (this.variadic) {
                if (this.postfix.length) {
                    js.const("firstPostfixIndex", `${js.data}.length${this.postfix.length ? `- ${this.postfix.length}` : ""}`);
                }
                js.for(`i < ${this.postfix.length ? "firstPostfixIndex" : "data.length"}`, () => js.traverseKey("i", "data[i]", this.variadic), this.prevariadic.length);
                this.postfix.forEach((node, i) => {
                    const keyExpression = `firstPostfixIndex + ${i}`;
                    js.traverseKey(keyExpression, `data[${keyExpression}]`, node);
                });
            }
            if (js.traversalKind === "Allows")
                js.return(true);
        }
        _transform(mapper, ctx) {
            ctx.path.push($ark.intrinsic.nonNegativeIntegerString);
            const result = super._transform(mapper, ctx);
            ctx.path.pop();
            return result;
        }
        tuple = sequenceInnerToTuple(this.inner);
        // this depends on tuple so needs to come after it
        expression = this.description;
    };
})();
export { SequenceNode };
const sequenceInnerToTuple = (inner) => {
    const tuple = [];
    inner.prefix?.forEach(node => tuple.push({ kind: "prefix", node }));
    inner.optionals?.forEach(node => tuple.push({ kind: "optionals", node }));
    if (inner.variadic)
        tuple.push({ kind: "variadic", node: inner.variadic });
    inner.postfix?.forEach(node => tuple.push({ kind: "postfix", node }));
    return tuple;
};
const sequenceTupleToInner = (tuple) => tuple.reduce((result, node) => {
    if (node.kind === "variadic")
        result.variadic = node.node;
    else
        result[node.kind] = append(result[node.kind], node.node);
    return result;
}, {});
export const postfixFollowingOptionalMessage = "A postfix required element cannot follow an optional element";
export const postfixWithoutVariadicMessage = "A postfix element requires a variadic element";
const _intersectSequences = (s) => {
    const [lHead, ...lTail] = s.l;
    const [rHead, ...rTail] = s.r;
    if (!lHead || !rHead)
        return s;
    const lHasPostfix = lTail.at(-1)?.kind === "postfix";
    const rHasPostfix = rTail.at(-1)?.kind === "postfix";
    const kind = lHead.kind === "prefix" || rHead.kind === "prefix" ? "prefix"
        : lHead.kind === "optionals" || rHead.kind === "optionals" ?
            // if either operand has postfix elements, the full-length
            // intersection can't include optional elements (though they may
            // exist in some of the fixed length variants)
            lHasPostfix || rHasPostfix ?
                "prefix"
                : "optionals"
            : lHead.kind === "postfix" || rHead.kind === "postfix" ? "postfix"
                : "variadic";
    if (lHead.kind === "prefix" && rHead.kind === "variadic" && rHasPostfix) {
        const postfixBranchResult = _intersectSequences({
            ...s,
            fixedVariants: [],
            r: rTail.map(element => ({ ...element, kind: "prefix" }))
        });
        if (postfixBranchResult.disjoint.length === 0)
            s.fixedVariants.push(postfixBranchResult);
    }
    else if (rHead.kind === "prefix" &&
        lHead.kind === "variadic" &&
        lHasPostfix) {
        const postfixBranchResult = _intersectSequences({
            ...s,
            fixedVariants: [],
            l: lTail.map(element => ({ ...element, kind: "prefix" }))
        });
        if (postfixBranchResult.disjoint.length === 0)
            s.fixedVariants.push(postfixBranchResult);
    }
    const result = intersectNodes(lHead.node, rHead.node, s.ctx);
    if (result instanceof Disjoint) {
        if (kind === "prefix" || kind === "postfix") {
            s.disjoint.push(...result.withPrefixKey(
            // TODO: more precise path handling for Disjoints
            kind === "prefix" ? `${s.result.length}` : `-${lTail.length + 1}`, "required"));
            s.result = [...s.result, { kind, node: $ark.intrinsic.never.internal }];
        }
        else if (kind === "optionals") {
            // if the element result is optional and unsatisfiable, the
            // intersection can still be satisfied as long as the tuple
            // ends before the disjoint element would occur
            return s;
        }
        else {
            // if the element is variadic and unsatisfiable, the intersection
            // can be satisfied with a fixed length variant including zero
            // variadic elements
            return _intersectSequences({
                ...s,
                fixedVariants: [],
                // if there were any optional elements, there will be no postfix elements
                // so this mapping will never occur (which would be illegal otherwise)
                l: lTail.map(element => ({ ...element, kind: "prefix" })),
                r: lTail.map(element => ({ ...element, kind: "prefix" }))
            });
        }
    }
    else
        s.result = [...s.result, { kind, node: result }];
    const lRemaining = s.l.length;
    const rRemaining = s.r.length;
    if (lHead.kind !== "variadic" ||
        (lRemaining >= rRemaining &&
            (rHead.kind === "variadic" || rRemaining === 1)))
        s.l = lTail;
    if (rHead.kind !== "variadic" ||
        (rRemaining >= lRemaining &&
            (lHead.kind === "variadic" || lRemaining === 1)))
        s.r = rTail;
    return _intersectSequences(s);
};
