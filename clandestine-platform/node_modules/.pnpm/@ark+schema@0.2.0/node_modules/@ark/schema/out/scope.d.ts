import { DynamicBase, ParseError, type Json, type array, type flattenListable, type show } from "@ark/util";
import { type ArkConfig, type ResolvedArkConfig } from "./config.js";
import { type GenericParamDef, type GenericRoot, type LazyGenericSchema, type genericParamSchemasToAst } from "./generic.js";
import type { inferRoot, validateRoot } from "./inference.js";
import type { internal } from "./keywords/internal.js";
import type { jsObjects } from "./keywords/jsObjects.js";
import type { tsKeywords } from "./keywords/tsKeywords.js";
import { type Node, type NodeSchema, type RootSchema, type reducibleKindOf } from "./kinds.js";
import { type PreparsedNodeResolution, type SchemaModule } from "./module.js";
import type { BaseNode } from "./node.js";
import { type NodeParseOptions } from "./parse.js";
import { type AliasNode } from "./roots/alias.js";
import type { BaseRoot, Root } from "./roots/root.js";
import type { NodeKind, RootKind } from "./shared/implement.js";
import { arkKind, type internalImplementationOf } from "./shared/utils.js";
export type nodeResolutions<keywords> = {
    [k in keyof keywords]: BaseRoot;
};
export type BaseResolutions = Record<string, BaseRoot>;
export type RawRootResolutions = Record<string, RawResolution | undefined>;
export type exportedNameOf<$> = Exclude<keyof $ & string, PrivateDeclaration>;
export type resolvableReferenceIn<$> = keyof $ extends infer k extends string ? k extends PrivateDeclaration<infer alias> ? alias : k : never;
export type resolveReference<reference extends resolvableReferenceIn<$>, $> = reference extends keyof $ ? $[reference] : $[`#${reference}` & keyof $];
export type PrivateDeclaration<key extends string = string> = `#${key}`;
type toRawScope<$> = RawRootScope<{
    [k in keyof $]: $[k] extends {
        [arkKind]: infer kind;
    } ? kind extends "generic" ? GenericRoot : kind extends "module" ? RawRootModule : never : BaseRoot;
}>;
export type IntrinsicKeywords = {
    [alias in keyof tsKeywords | keyof jsObjects | keyof internal]: BaseRoot;
};
export type RawResolution = BaseRoot | GenericRoot | RawRootModule;
type CachedResolution = string | RawResolution;
export declare const writeDuplicateAliasError: <alias extends string>(alias: alias) => writeDuplicateAliasError<alias>;
export type writeDuplicateAliasError<alias extends string> = `#${alias} duplicates public alias ${alias}`;
export type AliasDefEntry = [name: string, defValue: unknown];
export declare class RawRootScope<$ extends RawRootResolutions = RawRootResolutions> implements internalImplementationOf<RootScope, "t"> {
    readonly config: ArkConfig;
    readonly resolvedConfig: ResolvedArkConfig;
    readonly id: string;
    readonly [arkKind] = "scope";
    readonly referencesById: {
        [id: string]: BaseNode;
    };
    references: readonly BaseNode[];
    protected readonly resolutions: {
        [alias: string]: CachedResolution | undefined;
    };
    readonly json: Json;
    exportedNames: string[];
    readonly aliases: Record<string, unknown>;
    protected resolved: boolean;
    constructor(
    /** The set of names defined at the root-level of the scope mapped to their
     * corresponding definitions.**/
    def: Record<string, unknown>, config?: ArkConfig);
    get internal(): this;
    schema(def: RootSchema, opts?: NodeParseOptions): BaseRoot;
    defineRoot(def: RootSchema): RootSchema;
    generic(params: array<GenericParamDef>, def?: unknown): GenericRoot | ((def: LazyGenericSchema) => GenericRoot);
    units(values: array, opts?: NodeParseOptions): BaseRoot;
    protected lazyResolutions: AliasNode[];
    lazilyResolve(resolve: () => BaseRoot, syntheticAlias?: string): AliasNode;
    node<kinds extends NodeKind | array<RootKind>, prereduced extends boolean = false>(kinds: kinds, nodeSchema: NodeSchema<flattenListable<kinds>>, opts?: NodeParseOptions<prereduced>): Node<prereduced extends true ? flattenListable<kinds> : reducibleKindOf<flattenListable<kinds>>>;
    protected finalizeRootArgs(opts: NodeParseOptions, resolve: () => BaseRoot): NodeParseOptions;
    parseRoot(def: unknown, opts?: NodeParseOptions): BaseRoot;
    resolveRoot(name: string): BaseRoot;
    maybeResolveRoot(name: string): BaseRoot | undefined;
    maybeResolveGenericOrRoot(name: string): BaseRoot | GenericRoot | undefined;
    preparseRoot(def: unknown): unknown;
    preparseAlias(k: string, v: unknown): AliasDefEntry;
    maybeResolve(name: string): RawResolution | undefined;
    maybeShallowResolve(name: string): CachedResolution | undefined;
    /** If name is a valid reference to a submodule alias, return its resolution  */
    protected maybeResolveSubalias(name: string): BaseRoot | GenericRoot | undefined;
    import<names extends exportedNameOf<$>[]>(...names: names): show<destructuredImportContext<$, names>>;
    private _exportedResolutions;
    private _exports;
    export<names extends exportedNameOf<$>[]>(...names: names): show<destructuredExportContext<$, names>>;
    resolve<name extends exportedNameOf<$>>(name: name): destructuredExportContext<$, []>[name];
}
export type validateAliases<aliases> = {
    [k in keyof aliases]: aliases[k] extends PreparsedNodeResolution ? aliases[k] : validateRoot<aliases[k], aliases>;
};
export type instantiateAliases<aliases> = {
    [k in keyof aliases]: aliases[k] extends PreparsedNodeResolution ? aliases[k] : inferRoot<aliases[k], aliases>;
} & unknown;
export declare const schemaScope: <const aliases>(aliases: validateAliases<aliases>, config?: ArkConfig) => RootScope<instantiateAliases<aliases>>;
export interface RootScope<$ = any> {
    t: $;
    [arkKind]: "scope";
    config: ArkConfig;
    references: readonly BaseNode[];
    json: Json;
    exportedNames: array<exportedNameOf<$>>;
    /** The set of names defined at the root-level of the scope mapped to their
     * corresponding definitions.**/
    aliases: Record<string, unknown>;
    internal: toRawScope<$>;
    schema<const def extends RootSchema>(schema: def, opts?: NodeParseOptions): Root<inferRoot<def, $>, $>;
    defineRoot<const def extends RootSchema>(schema: def): def;
    units<const branches extends array>(values: branches, opts?: NodeParseOptions): Root<branches[number], $>;
    node<kinds extends NodeKind | array<RootKind>>(kinds: kinds, schema: NodeSchema<flattenListable<kinds>>, opts?: NodeParseOptions): Node<reducibleKindOf<flattenListable<kinds>>>;
    generic<const paramsDef extends array<GenericParamDef>, bodyDef extends LazyGenericSchema<genericParamSchemasToAst<paramsDef, $>> = never>(params: paramsDef, def?: bodyDef): [bodyDef] extends [never] ? <lazyDef extends LazyGenericSchema<genericParamSchemasToAst<paramsDef, $>>>(lazyDef: lazyDef) => GenericRoot<genericParamSchemasToAst<paramsDef, $>, ReturnType<lazyDef>, $> : GenericRoot<genericParamSchemasToAst<paramsDef, $>, bodyDef, $>;
    parseRoot(schema: unknown, opts?: NodeParseOptions): BaseRoot;
    import<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<show<destructuredImportContext<$, names>>>;
    export<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<show<destructuredExportContext<$, names>>>;
    resolve<name extends exportedNameOf<$>>(name: name): $[name] extends PreparsedNodeResolution ? $[name] : Root<$[name], $>;
}
export declare const RootScope: new <$ = any>(...args: ConstructorParameters<typeof RawRootScope>) => RootScope<$>;
export declare const root: RootScope<{}>;
export declare const schema: RootScope["schema"];
export declare const node: RootScope["node"];
export declare const defineRoot: RootScope["defineRoot"];
export declare const units: RootScope["units"];
export declare const generic: RootScope["generic"];
export declare const internalSchema: RawRootScope["schema"];
export declare const internalNode: RawRootScope["node"];
export declare const defineInternalRoot: RawRootScope["defineRoot"];
export declare const internalUnits: RawRootScope["units"];
export declare const internalGeneric: RawRootScope["generic"];
export declare const parseAsSchema: <castTo = unknown>(def: unknown, opts?: NodeParseOptions) => Root<castTo, {}> | ParseError;
export declare class RawRootModule<resolutions extends RawRootResolutions = RawRootResolutions> extends DynamicBase<resolutions> {
    readonly [arkKind]: "module";
}
export type destructuredExportContext<$, names extends exportedNameOf<$>[]> = {
    [k in names extends [] ? exportedNameOf<$> : names[number]]: $[k];
};
export type destructuredImportContext<$, names extends exportedNameOf<$>[]> = {
    [k in names extends [] ? exportedNameOf<$> : names[number] as `#${k & string}`]: $[k];
};
export type RootExportCache = Record<string, BaseRoot | GenericRoot | RawRootModule | undefined>;
export declare const writeUnresolvableMessage: <token extends string>(token: token) => writeUnresolvableMessage<token>;
export type writeUnresolvableMessage<token extends string> = `'${token}' is unresolvable`;
export declare const writeNonSubmoduleDotMessage: <name extends string>(name: name) => writeNonSubmoduleDotMessage<name>;
export type writeNonSubmoduleDotMessage<name extends string> = `'${name}' must reference a module to be accessed using dot syntax`;
export declare const writeMissingSubmoduleAccessMessage: <name extends string>(name: name) => writeMissingSubmoduleAccessMessage<name>;
export type writeMissingSubmoduleAccessMessage<name extends string> = `Reference to submodule '${name}' must specify an alias`;
export declare const bindCompiledScope: (references: readonly BaseNode[]) => void;
export {};
