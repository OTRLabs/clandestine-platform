import { type array, type propValueOf, type satisfy } from "@ark/util";
import { RawPrimitiveConstraint } from "../constraint.js";
import type { Node } from "../kinds.js";
import type { BaseMeta, RawNodeDeclaration } from "../shared/declare.js";
import type { KeySchemaDefinitions, RangeKind } from "../shared/implement.js";
export interface BaseRangeDeclaration extends RawNodeDeclaration {
    kind: RangeKind;
    inner: BaseRangeInner;
    normalizedSchema: UnknownNormalizedRangeSchema;
}
export declare abstract class BaseRange<d extends BaseRangeDeclaration> extends RawPrimitiveConstraint<d> {
    readonly boundOperandKind: OperandKindsByBoundKind[d["kind"]];
    readonly compiledActual: string;
    readonly comparator: RelativeComparator;
    readonly numericLimit: number;
    readonly expression: string;
    readonly compiledCondition: string;
    readonly compiledNegation: string;
    readonly stringLimit: string;
    readonly limitKind: LimitKind;
    isStricterThan(r: Node<d["kind"] | pairedRangeKind<d["kind"]>>): boolean;
    overlapsRange(r: Node<pairedRangeKind<d["kind"]>>): boolean;
    overlapIsUnit(r: Node<pairedRangeKind<d["kind"]>>): boolean;
}
export interface BaseRangeInner extends BaseMeta {
    readonly rule: number | Date;
    readonly exclusive?: true;
}
export type LimitSchemaValue = Date | number | string;
export type LimitInnerValue<kind extends RangeKind = RangeKind> = kind extends "before" | "after" ? Date : number;
export interface UnknownNormalizedRangeSchema extends BaseMeta {
    readonly rule: LimitSchemaValue;
    readonly exclusive?: boolean;
}
export type UnknownRangeSchema = LimitSchemaValue | UnknownNormalizedRangeSchema;
export interface ExclusiveNormalizedDateRangeSchema extends BaseMeta {
    rule: LimitSchemaValue;
    exclusive?: true;
}
export type ExclusiveDateRangeSchema = LimitSchemaValue | ExclusiveNormalizedDateRangeSchema;
export interface InclusiveNormalizedDateRangeSchema extends BaseMeta {
    rule: LimitSchemaValue;
    exclusive?: false;
}
export type InclusiveDateRangeSchema = LimitSchemaValue | InclusiveNormalizedDateRangeSchema;
export interface ExclusiveNormalizedNumericRangeSchema extends BaseMeta {
    rule: number;
    exclusive?: true;
}
export type ExclusiveNumericRangeSchema = number | ExclusiveNormalizedNumericRangeSchema;
export interface InclusiveNormalizedNumericRangeSchema extends BaseMeta {
    rule: number;
    exclusive?: false;
}
export type InclusiveNumericRangeSchema = number | InclusiveNormalizedNumericRangeSchema;
export type LimitKind = "lower" | "upper";
export type RelativeComparator<kind extends LimitKind = LimitKind> = {
    lower: ">" | ">=";
    upper: "<" | "<=";
}[kind];
export declare const boundKindPairsByLower: BoundKindPairsByLower;
type BoundKindPairsByLower = {
    min: "max";
    minLength: "maxLength";
    after: "before";
};
type BoundKindPairsByUpper = {
    max: "min";
    maxLength: "minLength";
    before: "after";
};
export type pairedRangeKind<kind extends RangeKind> = kind extends LowerBoundKind ? BoundKindPairsByLower[kind] : BoundKindPairsByUpper[kind & UpperBoundKind];
export type LowerBoundKind = keyof typeof boundKindPairsByLower;
export type LowerNode = Node<LowerBoundKind>;
export type UpperBoundKind = propValueOf<typeof boundKindPairsByLower>;
export type UpperNode = Node<UpperBoundKind>;
export type NumericallyBoundable = string | number | array;
export type Boundable = NumericallyBoundable | Date;
export declare const parseExclusiveKey: KeySchemaDefinitions<BaseRangeDeclaration>["exclusive"];
export declare const parseDateLimit: (limit: LimitSchemaValue) => Date;
type OperandKindsByBoundKind = satisfy<Record<RangeKind, BoundOperandKind>, {
    min: "value";
    max: "value";
    minLength: "length";
    maxLength: "length";
    after: "date";
    before: "date";
}>;
export declare const compileComparator: (kind: RangeKind, exclusive: boolean | undefined) => RelativeComparator;
export type BoundOperandKind = "value" | "length" | "date";
export type LengthBoundableData = string | array;
export type DateRangeKind = "before" | "after";
export declare const dateLimitToString: (limit: LimitSchemaValue) => string;
export declare const writeUnboundableMessage: <root extends string>(root: root) => writeUnboundableMessage<root>;
export type writeUnboundableMessage<root extends string> = `Bounded expression ${root} must be a number, string, Array, or Date`;
export {};
