import type { array } from "@ark/util";
import type { ResolvedArkConfig } from "../config.js";
import type { Morph } from "../roots/morph.js";
import { ArkError, ArkErrors, type ArkErrorCode, type ArkErrorInput } from "./errors.js";
import type { TraversalPath } from "./utils.js";
export type QueuedMorphs = {
    path: TraversalPath;
    morphs: array<Morph>;
};
export type BranchTraversalContext = {
    error: ArkError | undefined;
    queuedMorphs: QueuedMorphs[];
};
export declare class TraversalContext {
    root: unknown;
    config: ResolvedArkConfig;
    path: TraversalPath;
    queuedMorphs: QueuedMorphs[];
    errors: ArkErrors;
    branches: BranchTraversalContext[];
    seen: {
        [id in string]?: unknown[];
    };
    constructor(root: unknown, config: ResolvedArkConfig);
    get currentBranch(): BranchTraversalContext | undefined;
    queueMorphs(morphs: array<Morph>): void;
    finalize(): unknown;
    get currentErrorCount(): number;
    hasError(): boolean;
    get failFast(): boolean;
    error<input extends ArkErrorInput>(input: input): ArkError<input extends {
        code: ArkErrorCode;
    } ? input["code"] : "predicate">;
    get data(): unknown;
    reject(input: ArkErrorInput): false;
    mustBe(expected: string): false;
    pushBranch(): void;
    popBranch(): BranchTraversalContext;
}
export type TraversalMethodsByKind<input = unknown> = {
    Allows: TraverseAllows<input>;
    Apply: TraverseApply<input>;
};
export type TraversalKind = keyof TraversalMethodsByKind;
export type TraverseAllows<data = unknown> = (data: data, ctx: TraversalContext) => boolean;
export type TraverseApply<data = unknown> = (data: data, ctx: TraversalContext) => void;
