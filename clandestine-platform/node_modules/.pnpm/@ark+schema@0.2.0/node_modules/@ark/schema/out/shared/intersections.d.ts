import { Hkt, type array, type conform, type intersectArrays, type isAny, type show } from "@ark/util";
import type { Constraints, of, parseConstraints } from "../ast.js";
import type { BaseNode } from "../node.js";
import type { MorphAst, MorphNode, Out } from "../roots/morph.js";
import type { BaseRoot } from "../roots/root.js";
import type { RawRootScope } from "../scope.js";
import { Disjoint } from "./disjoint.js";
import type { IntersectionContext, RootKind } from "./implement.js";
export type inferIntersection<l, r> = _inferIntersection<l, r, false>;
export type inferPipe<l, r> = _inferIntersection<l, r, true>;
type _inferIntersection<l, r, piped extends boolean> = [
    l
] extends [never] ? never : [r] extends [never] ? never : [l & r] extends [never] ? never : isAny<l | r> extends true ? any : l extends MorphAst<infer lIn, infer lOut> ? r extends MorphAst<any, infer rOut> ? piped extends true ? (In: lIn) => Out<rOut> : never : piped extends true ? (In: lIn) => Out<r> : (In: _inferIntersection<lIn, r, false>) => Out<lOut> : r extends MorphAst<infer rIn, infer rOut> ? (In: _inferIntersection<rIn, l, false>) => Out<rOut> : parseConstraints<l> extends ([
    infer lBase,
    infer lConstraints extends Constraints
]) ? parseConstraints<r> extends ([
    infer rBase,
    infer rConstraints extends Constraints
]) ? of<_inferIntersection<lBase, rBase, piped>, lConstraints & rConstraints> : of<_inferIntersection<lBase, r, piped>, lConstraints> : parseConstraints<r> extends ([
    infer rBase,
    infer rConstraints extends Constraints
]) ? of<_inferIntersection<l, rBase, piped>, rConstraints> : [l, r] extends [object, object] ? intersectObjects<l, r, piped> extends infer result ? result : never : l & r;
declare class MorphableIntersection<piped extends boolean> extends Hkt.Kind {
    hkt: (In: conform<this[Hkt.args], [l: unknown, r: unknown]>) => _inferIntersection<(typeof In)[0], (typeof In)[1], piped>;
}
type intersectObjects<l, r, piped extends boolean> = [
    l,
    r
] extends [infer lList extends array, infer rList extends array] ? intersectArrays<lList, rList, MorphableIntersection<piped>> : show<{
    [k in keyof l]: k extends keyof r ? _inferIntersection<l[k], r[k], piped> : l[k];
} & {
    [k in keyof r]: k extends keyof l ? _inferIntersection<l[k], r[k], piped> : r[k];
}>;
type InternalNodeIntersection<ctx> = <l extends BaseNode, r extends BaseNode>(l: l, r: r, ctx: ctx) => l["kind"] | r["kind"] extends RootKind ? BaseRoot | Disjoint : BaseNode | Disjoint | null;
export declare const intersectNodesRoot: InternalNodeIntersection<RawRootScope>;
export declare const pipeNodesRoot: InternalNodeIntersection<RawRootScope>;
export declare const intersectNodes: InternalNodeIntersection<IntersectionContext>;
export declare const pipeFromMorph: (from: MorphNode, to: BaseRoot, ctx: IntersectionContext) => MorphNode | Disjoint;
export declare const pipeToMorph: (from: BaseRoot, to: MorphNode, ctx: IntersectionContext) => MorphNode | Disjoint;
export {};
