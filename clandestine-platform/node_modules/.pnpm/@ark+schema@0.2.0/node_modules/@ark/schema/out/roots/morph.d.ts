import { type array, type listable } from "@ark/util";
import type { distillConstrainableIn } from "../ast.js";
import type { type } from "../inference.js";
import type { Node, NodeSchema } from "../kinds.js";
import type { NodeCompiler } from "../shared/compile.js";
import type { BaseMeta, declareNode } from "../shared/declare.js";
import type { ArkError, ArkErrors } from "../shared/errors.js";
import { type nodeImplementationOf } from "../shared/implement.js";
import { type inferPipe } from "../shared/intersections.js";
import type { TraversalContext, TraverseAllows, TraverseApply } from "../shared/traversal.js";
import { BaseRoot, type Root, type schemaKindRightOf } from "./root.js";
export type MorphChildKind = schemaKindRightOf<"morph"> | "alias";
export type MorphChildNode = Node<MorphChildKind>;
export type MorphChildSchema = NodeSchema<MorphChildKind>;
export type Morph<i = any, o = unknown> = (In: i, ctx: TraversalContext) => o;
export type Out<o = any> = ["=>", o];
export type MorphAst<i = any, o = any> = (In: i) => Out<o>;
export interface MorphInner extends BaseMeta {
    readonly in: MorphChildNode;
    readonly morphs: array<Morph | Root>;
}
export interface MorphSchema extends BaseMeta {
    readonly in: MorphChildSchema;
    readonly morphs: listable<Morph | Root>;
}
export interface MorphDeclaration extends declareNode<{
    kind: "morph";
    schema: MorphSchema;
    normalizedSchema: MorphSchema;
    inner: MorphInner;
    childKind: MorphChildKind;
}> {
}
export declare const morphImplementation: nodeImplementationOf<MorphDeclaration>;
export declare class MorphNode extends BaseRoot<MorphDeclaration> {
    serializedMorphs: string[];
    compiledMorphs: string;
    structure: import("../index.js").StructureNode | undefined;
    traverseAllows: TraverseAllows;
    traverseApply: TraverseApply;
    expression: string;
    get shortDescription(): string;
    compile(js: NodeCompiler): void;
    get in(): MorphChildNode;
    get out(): BaseRoot;
    /** Check if the morphs of r are equal to those of this node */
    hasEqualMorphs(r: MorphNode): boolean;
    lastMorph: Morph<any, unknown> | Root<unknown, any> | undefined;
    validatedOut: BaseRoot | undefined;
    rawKeyOf(): BaseRoot;
}
export declare const writeMorphIntersectionMessage: (lDescription: string, rDescription: string) => string;
export type inferPipes<t, pipes extends Morph[]> = pipes extends [infer head extends Morph, ...infer tail extends Morph[]] ? inferPipes<pipes[0] extends type.cast<infer tPipe> ? inferPipe<t, tPipe> : inferMorphOut<head> extends infer out ? (In: distillConstrainableIn<t>) => Out<out> : never, tail> : t;
export type inferMorphOut<morph extends Morph> = Exclude<ReturnType<morph>, ArkError | ArkErrors>;
