import { ArkError, ArkErrors } from "./errors.js";
export class TraversalContext {
    root;
    config;
    path = [];
    queuedMorphs = [];
    errors = new ArkErrors(this);
    branches = [];
    seen = {};
    constructor(root, config) {
        this.root = root;
        this.config = config;
    }
    get currentBranch() {
        return this.branches.at(-1);
    }
    queueMorphs(morphs) {
        const input = {
            path: [...this.path],
            morphs
        };
        this.currentBranch?.queuedMorphs.push(input) ??
            this.queuedMorphs.push(input);
    }
    finalize() {
        if (this.hasError())
            return this.errors;
        // invoking morphs that are Nodes will reuse this context, potentially
        // adding additional morphs, so we have to continue looping until
        // queuedMorphs is empty rather than iterating over the list once
        while (this.queuedMorphs.length) {
            const { path, morphs } = this.queuedMorphs.shift();
            const key = path.at(-1);
            let parent;
            if (key !== undefined) {
                // find the object on which the key to be morphed exists
                parent = this.root;
                for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)
                    parent = parent[path[pathIndex]];
            }
            this.path = path;
            for (const morph of morphs) {
                const result = morph(parent === undefined ? this.root : parent[key], this);
                if (result instanceof ArkErrors)
                    return result;
                if (this.hasError())
                    return this.errors;
                if (result instanceof ArkError) {
                    // if an ArkError was returned but wasn't added to these
                    // errors, add it then return
                    this.error(result);
                    return this.errors;
                }
                // apply the morph function and assign the result to the
                // corresponding property, or to root if path is empty
                if (parent === undefined)
                    this.root = result;
                else
                    parent[key] = result;
            }
        }
        return this.root;
    }
    get currentErrorCount() {
        return (this.currentBranch ?
            this.currentBranch.error ?
                1
                : 0
            : this.errors.count);
    }
    hasError() {
        return this.currentErrorCount !== 0;
    }
    get failFast() {
        return this.branches.length !== 0;
    }
    error(input) {
        const errCtx = typeof input === "object" ?
            input.code ?
                input
                : { ...input, code: "predicate" }
            : { code: "predicate", expected: input };
        const error = new ArkError(errCtx, this);
        if (this.currentBranch)
            this.currentBranch.error = error;
        else
            this.errors.add(error);
        return error;
    }
    get data() {
        let result = this.root;
        for (const segment of this.path)
            result = result?.[segment];
        return result;
    }
    reject(input) {
        this.error(input);
        return false;
    }
    mustBe(expected) {
        this.error(expected);
        return false;
    }
    pushBranch() {
        this.branches.push({
            error: undefined,
            queuedMorphs: []
        });
    }
    popBranch() {
        return this.branches.pop();
    }
}
