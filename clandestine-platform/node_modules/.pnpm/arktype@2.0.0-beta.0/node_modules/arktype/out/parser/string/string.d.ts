import type { BaseRoot, resolvableReferenceIn } from "@ark/schema";
import { type ErrorMessage } from "@ark/util";
import type { inferAstRoot } from "../semantic/infer.js";
import type { DynamicState, DynamicStateWithRoot } from "./reduce/dynamic.js";
import type { StringifiablePrefixOperator } from "./reduce/shared.js";
import type { state, StaticState } from "./reduce/static.js";
import type { parseOperand } from "./shift/operand/operand.js";
import { parseDefault, type ParsedDefault } from "./shift/operator/default.js";
import { writeUnexpectedCharacterMessage, type parseOperator } from "./shift/operator/operator.js";
/**
 * Try to parse the definition from right to left using the most common syntax.
 * This can be much more efficient for simple definitions.
 */
export type parseString<def extends string, $, args> = def extends keyof $ ? def : def extends `${infer child}[]` ? child extends keyof $ ? [
    child,
    "[]"
] : fullStringParse<state.initialize<def>, $, args> : fullStringParse<state.initialize<def>, $, args>;
export type inferString<def extends string, $, args> = inferAstRoot<parseString<def, $, args>, $, args>;
export type BaseCompletions<$, args, otherSuggestions extends string = never> = resolvableReferenceIn<$> | resolvableReferenceIn<ArkEnv.$> | (keyof args & string) | StringifiablePrefixOperator | otherSuggestions;
export type StringParseResult = BaseRoot | ParsedDefault;
export declare const fullStringParse: (s: DynamicState) => StringParseResult;
type fullStringParse<s extends StaticState, $, args> = extractFinalizedResult<parseUntilFinalizer<s, $, args>>;
export declare const parseUntilFinalizer: (s: DynamicState) => DynamicStateWithRoot;
export type parseUntilFinalizer<s extends StaticState, $, args> = s["finalizer"] extends undefined ? parseUntilFinalizer<next<s, $, args>, $, args> : s;
declare const next: (s: DynamicState) => void;
type next<s extends StaticState, $, args> = s["root"] extends undefined ? parseOperand<s, $, args> : parseOperator<s, $, args>;
export type extractFinalizedResult<s extends StaticState> = s["finalizer"] extends "" ? s["root"] : s["finalizer"] extends ErrorMessage ? s["finalizer"] : s["finalizer"] extends "=" ? parseDefault<s["root"], s["unscanned"]> : state.error<writeUnexpectedCharacterMessage<`${s["finalizer"]}`>>;
export {};
