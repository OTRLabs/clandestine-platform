import { throwInternalError } from "./errors.js";
import { NoopBase, unset } from "./records.js";
export const bound = (target, ctx) => {
    ctx.addInitializer(function () {
        this[ctx.name] = this[ctx.name].bind(this);
    });
};
export const cached = (target, context) => function () {
    const value = target.call(this);
    Object.defineProperty(this, context.name, context.kind === "getter" ?
        { value }
        : {
            value: () => value,
            enumerable: false
        });
    return value;
};
export const cachedThunk = (thunk) => {
    let result = unset;
    return () => (result === unset ? (result = thunk()) : result);
};
export const isThunk = (value) => typeof value === "function" && value.length === 0;
export const tryCatch = (fn, onError) => {
    try {
        return fn();
    }
    catch (e) {
        return onError?.(e);
    }
};
export const DynamicFunction = class extends Function {
    constructor(...args) {
        const params = args.slice(0, -1);
        const body = args.at(-1);
        try {
            super(...params, body);
        }
        catch (e) {
            return throwInternalError(`Encountered an unexpected error while compiling your definition:
                Message: ${e} 
                Source: (${args.slice(0, -1)}) => {
                    ${args.at(-1)}
                }`);
        }
    }
};
/** @ts-expect-error required to cast function type */
export class Callable extends NoopBase {
    constructor(f, opts) {
        super();
        return Object.assign(Object.setPrototypeOf(f.bind(opts?.bind ?? this), this.constructor.prototype), opts?.attach);
    }
}
/**
 * Checks if the environment has Content Security Policy (CSP) enabled,
 * preventing JIT-optimized code from being compiled via new Function().
 *
 * @returns `true` if a function created using new Function() can be
 * successfully invoked in the environment, `false` otherwise.
 *
 * The result is cached for subsequent invocations.
 */
export const envHasCsp = cachedThunk(() => {
    try {
        return new Function("return false")();
    }
    catch (e) {
        return true;
    }
});
