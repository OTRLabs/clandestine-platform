import type { DivisorSchema, ExactLengthSchema, ExclusiveDateRangeSchema, ExclusiveNumericRangeSchema, FlatRef, InclusiveDateRangeSchema, InclusiveNumericRangeSchema, LimitSchemaValue, PatternSchema, TypeKey, TypePath, UnknownRangeSchema } from "@ark/schema";
import { type Callable, type Json, type array, type conform } from "@ark/util";
import type { constrain, distillConstrainableIn, distillConstrainableOut, distillIn, distillOut } from "../ast.js";
import { type PrimitiveConstraintKind } from "../constraint.js";
import type { Node, NodeSchema, reducibleKindOf } from "../kinds.js";
import { BaseNode } from "../node.js";
import type { Predicate } from "../predicate.js";
import type { RootScope } from "../scope.js";
import type { BaseMeta, RawNodeDeclaration } from "../shared/declare.js";
import { Disjoint } from "../shared/disjoint.js";
import { ArkErrors } from "../shared/errors.js";
import { type NodeKind, type RootKind, type kindRightOf } from "../shared/implement.js";
import { type inferIntersection } from "../shared/intersections.js";
import { arkKind, type inferred, type internalImplementationOf } from "../shared/utils.js";
import type { UndeclaredKeyBehavior } from "../structure/structure.js";
import type { constraintKindOf } from "./intersection.js";
import type { Morph, MorphNode, inferMorphOut, inferPipes } from "./morph.js";
import type { UnionChildKind } from "./union.js";
export interface RawRootDeclaration extends RawNodeDeclaration {
    kind: RootKind;
}
export type UnknownRoot<t = unknown> = Root<t> | BaseRoot;
export type TypeOnlyRootKey = (keyof Root & symbol) | "infer" | "inferIn" | "t" | "tIn" | "tOut";
export declare abstract class BaseRoot<
/** uses -ignore rather than -expect-error because this is not an error in .d.ts
 * @ts-ignore allow instantiation assignment to the base type */
out d extends RawRootDeclaration = RawRootDeclaration> extends BaseNode<d> implements internalImplementationOf<Root, TypeOnlyRootKey | "intersect"> {
    readonly branches: readonly Node<UnionChildKind>[];
    readonly [arkKind] = "root";
    get internal(): this;
    abstract rawKeyOf(): BaseRoot;
    abstract get shortDescription(): string;
    keyof(): BaseRoot;
    protected intersect(r: unknown): BaseRoot | Disjoint;
    and(r: unknown): BaseRoot;
    or(r: unknown): BaseRoot;
    assert(data: unknown): unknown;
    get(...[key, ...tail]: TypePath): BaseRoot;
    extract(r: unknown): BaseRoot;
    exclude(r: UnknownRoot): BaseRoot;
    array(): BaseRoot;
    overlaps(r: UnknownRoot): boolean;
    extends(r: UnknownRoot): boolean;
    subsumes(r: UnknownRoot): boolean;
    includes(r: unknown): boolean;
    configure(configOrDescription: BaseMeta | string): this;
    describe(description: string): this;
    from(input: unknown): unknown;
    pipe(...morphs: Morph[]): BaseRoot;
    private pipeOnce;
    get flatMorphs(): array<FlatRef<MorphNode>>;
    narrow(predicate: Predicate): BaseRoot;
    constrain<kind extends PrimitiveConstraintKind>(kind: kind, schema: NodeSchema<kind>): BaseRoot;
    constrainOut<kind extends PrimitiveConstraintKind>(kind: kind, schema: NodeSchema<kind>): BaseRoot;
    private _constrain;
    onUndeclaredKey(cfg: UndeclaredKeyBehavior | UndeclaredKeyConfig): BaseRoot;
    satisfying(predicate: Predicate): BaseRoot;
    divisibleBy(schema: DivisorSchema): BaseRoot;
    matching(schema: PatternSchema): BaseRoot;
    atLeast(schema: InclusiveNumericRangeSchema): BaseRoot;
    atMost(schema: InclusiveNumericRangeSchema): BaseRoot;
    moreThan(schema: ExclusiveNumericRangeSchema): BaseRoot;
    lessThan(schema: ExclusiveNumericRangeSchema): BaseRoot;
    atLeastLength(schema: InclusiveNumericRangeSchema): BaseRoot;
    atMostLength(schema: InclusiveNumericRangeSchema): BaseRoot;
    moreThanLength(schema: ExclusiveNumericRangeSchema): BaseRoot;
    lessThanLength(schema: ExclusiveNumericRangeSchema): BaseRoot;
    exactlyLength(schema: ExactLengthSchema): BaseRoot;
    atOrAfter(schema: InclusiveDateRangeSchema): BaseRoot;
    atOrBefore(schema: InclusiveDateRangeSchema): BaseRoot;
    laterThan(schema: ExclusiveDateRangeSchema): BaseRoot;
    earlierThan(schema: ExclusiveDateRangeSchema): BaseRoot;
}
export type UndeclaredKeyConfig = {
    rule: UndeclaredKeyBehavior;
    deep?: boolean;
};
export declare const exclusivizeRangeSchema: <schema extends UnknownRangeSchema>(schema: schema) => schema;
export type exclusivizeRangeSchema<schema extends UnknownRangeSchema> = schema extends LimitSchemaValue ? {
    rule: schema;
    exclusive: true;
} : schema;
export declare abstract class InnerRoot<t = unknown, $ = any> extends Callable<(data: unknown) => distillOut<t> | ArkErrors> {
    t: t;
    tIn: distillConstrainableIn<t>;
    tOut: distillConstrainableOut<t>;
    infer: distillOut<t>;
    inferIn: distillIn<t>;
    [inferred]: t;
    json: Json;
    description: string;
    expression: string;
    internal: BaseRoot;
    abstract $: RootScope<$>;
    abstract get in(): unknown;
    abstract get out(): unknown;
    abstract keyof(): unknown;
    abstract intersect(r: never): unknown | Disjoint;
    abstract and(r: never): unknown;
    abstract or(r: never): unknown;
    abstract constrain(kind: never, schema: never): unknown;
    abstract equals(r: never): this is unknown;
    abstract extract(r: never): unknown;
    abstract exclude(r: never): unknown;
    abstract extends(r: never): this is unknown;
    abstract overlaps(r: never): boolean;
    abstract array(): unknown;
    abstract pipe(morph: Morph): unknown;
    assert(data: unknown): this["infer"];
    allows(data: unknown): data is this["inferIn"];
    traverse(data: unknown): distillOut<t> | ArkErrors;
    configure(configOrDescription: BaseMeta | string): this;
    describe(description: string): this;
    onUndeclaredKey(behavior: UndeclaredKeyBehavior): this;
    from(literal: this["inferIn"]): this["infer"];
}
declare class _Root<t = unknown, $ = any> extends InnerRoot<t, $> {
    $: RootScope<$>;
    get in(): Root<this["tIn"], $>;
    get out(): Root<this["tOut"], $>;
    keyof(): Root<keyof this["inferIn"], $>;
    intersect<r extends Root>(r: r): Root<inferIntersection<t, r["t"]>> | Disjoint;
    and<r extends Root>(r: r): Root<inferIntersection<t, r["t"]>>;
    or<r extends Root>(r: r): Root<t | r["t"]>;
    array(): Root<t[], $>;
    constrain<kind extends PrimitiveConstraintKind, const schema extends NodeSchema<kind>>(kind: conform<kind, constraintKindOf<this["inferIn"]>>, schema: schema): Root<constrain<t, kind, schema>, $>;
    equals<r>(r: Root<r>): this is Root<r>;
    extract<r>(r: Root<r>): Root<t, $>;
    exclude<r>(r: Root<r>): Root<t, $>;
    extends<r>(other: Root<r>): this is Root<r> & {
        [inferred]?: r;
    };
    pipe<a extends Morph<this["infer"]>>(a: a): Root<inferPipes<t, [a]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>>(a: a, b: b): Root<inferPipes<t, [a, b]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>>(a: a, b: b, c: c): Root<inferPipes<t, [a, b, c]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>>(a: a, b: b, c: c, d: d): Root<inferPipes<t, [a, b, c, d]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>>(a: a, b: b, c: c, d: d, e: e): Root<inferPipes<t, [a, b, c, d, e]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>>(a: a, b: b, c: c, d: d, e: e, f: f): Root<inferPipes<t, [a, b, c, d, e, f]>, $>;
    pipe<a extends Morph<this["infer"]>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g): Root<inferPipes<t, [a, b, c, d, e, f, g]>, $>;
    overlaps(r: Root): boolean;
}
export declare const writeNonStructuralIndexAccessMessage: (key: TypeKey) => string;
export interface Root<
/** @ts-expect-error allow instantiation assignment to the base type */
out t = unknown, $ = any> extends _Root<t, $> {
}
export type intersectRoot<l extends RootKind, r extends NodeKind> = [
    l,
    r
] extends [r, l] ? l : asymmetricIntersectionOf<l, r> | asymmetricIntersectionOf<r, l>;
type asymmetricIntersectionOf<l extends NodeKind, r extends NodeKind> = l extends unknown ? r extends kindRightOf<l> ? l | reducibleKindOf<l> : never : never;
export type schemaKindRightOf<kind extends RootKind> = Extract<kindRightOf<kind>, RootKind>;
export type schemaKindOrRightOf<kind extends RootKind> = kind | schemaKindRightOf<kind>;
export {};
