import { entriesOf, hasDomain, isArray, printable, throwParseError, unset } from "@ark/util";
import { nodeClassesByKind, nodeImplementationsByKind } from "./kinds.js";
import { Disjoint } from "./shared/disjoint.js";
import { constraintKeys, defaultValueSerializer, isNodeKind, precedenceOfKind } from "./shared/implement.js";
import { hasArkKind } from "./shared/utils.js";
export const schemaKindOf = (schema, allowedKinds) => {
    const kind = discriminateRootKind(schema);
    if (allowedKinds && !allowedKinds.includes(kind)) {
        return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);
    }
    return kind;
};
const discriminateRootKind = (schema) => {
    if (hasArkKind(schema, "root"))
        return schema.kind;
    if (typeof schema === "string")
        return schema[0] === "$" ? "alias" : "domain";
    if (typeof schema === "function")
        return "proto";
    // throw at end of function
    if (typeof schema !== "object" || schema === null)
        return throwParseError(writeInvalidSchemaMessage(schema));
    if ("morphs" in schema)
        return "morph";
    if ("branches" in schema || isArray(schema))
        return "union";
    if ("unit" in schema)
        return "unit";
    if ("alias" in schema)
        return "alias";
    const schemaKeys = Object.keys(schema);
    if (schemaKeys.length === 0 || schemaKeys.some(k => k in constraintKeys))
        return "intersection";
    if ("proto" in schema)
        return "proto";
    if ("domain" in schema)
        return "domain";
    return throwParseError(writeInvalidSchemaMessage(schema));
};
export const writeInvalidSchemaMessage = (schema) => `${printable(schema)} is not a valid type schema`;
const nodeCache = {};
const nodeCountsByPrefix = {};
const serializeListableChild = (listableNode) => isArray(listableNode) ?
    listableNode.map(node => node.collapsibleJson)
    : listableNode.collapsibleJson;
export const registerNodeId = (kind, opts) => {
    const prefix = opts.alias ?? kind;
    nodeCountsByPrefix[prefix] ??= 0;
    return `${prefix}${++nodeCountsByPrefix[prefix]}`;
};
export const parseNode = (id, kind, schema, $, opts) => {
    const ctx = {
        ...opts,
        $,
        args: opts.args ?? {},
        schema,
        id
    };
    return _parseNode(kind, ctx);
};
const _parseNode = (kind, ctx) => {
    const impl = nodeImplementationsByKind[kind];
    const inner = {};
    // ensure node entries are parsed in order of precedence, with non-children
    // parsed first
    const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ?
        isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey)
            : 1
        : isNodeKind(rKey) ? -1
            : lKey < rKey ? -1
                : 1);
    const children = [];
    for (const entry of schemaEntries) {
        const k = entry[0];
        const keyImpl = impl.keys[k];
        if (!keyImpl)
            return throwParseError(`Key ${k} is not valid on ${kind} schema`);
        const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];
        if (v !== unset && (v !== undefined || keyImpl.preserveUndefined))
            inner[k] = v;
    }
    const entries = entriesOf(inner);
    let json = {};
    let typeJson = {};
    entries.forEach(([k, v]) => {
        const keyImpl = impl.keys[k];
        const serialize = keyImpl.serialize ??
            (keyImpl.child ? serializeListableChild : defaultValueSerializer);
        json[k] = serialize(v);
        if (keyImpl.child) {
            const listableNode = v;
            if (isArray(listableNode))
                children.push(...listableNode);
            else
                children.push(listableNode);
        }
        if (!keyImpl.meta)
            typeJson[k] = json[k];
    });
    if (impl.finalizeJson) {
        json = impl.finalizeJson(json);
        typeJson = impl.finalizeJson(typeJson);
    }
    let collapsibleJson = json;
    const collapsibleKeys = Object.keys(collapsibleJson);
    if (collapsibleKeys.length === 1 &&
        collapsibleKeys[0] === impl.collapsibleKey) {
        collapsibleJson = collapsibleJson[impl.collapsibleKey];
        if (
        // if the collapsibleJson is still an object
        hasDomain(collapsibleJson, "object") &&
            // and the JSON did not include any implied keys
            Object.keys(json).length === 1) {
            // we can replace it with its collapsed value
            json = collapsibleJson;
            typeJson = collapsibleJson;
        }
    }
    const innerHash = JSON.stringify({ kind, ...json });
    if (ctx.reduceTo) {
        nodeCache[innerHash] = ctx.reduceTo;
        return ctx.reduceTo;
    }
    const typeHash = JSON.stringify({ kind, ...typeJson });
    if (impl.reduce && !ctx.prereduced) {
        const reduced = impl.reduce(inner, ctx.$);
        if (reduced) {
            if (reduced instanceof Disjoint)
                return reduced.throw();
            // if we're defining the resolution of an alias and the result is
            // reduced to another node, add the alias to that node if it doesn't
            // already have one.
            if (ctx.alias)
                reduced.alias ??= ctx.alias;
            // we can't cache this reduction for now in case the reduction involved
            // impliedSiblings
            return reduced;
        }
    }
    // we have to wait until after reduction to return a cached entry,
    // since reduction can add impliedSiblings
    if (nodeCache[innerHash])
        return nodeCache[innerHash];
    const attachments = {
        id: ctx.id,
        kind,
        impl,
        inner,
        entries,
        json: json,
        typeJson: typeJson,
        collapsibleJson: collapsibleJson,
        children,
        innerHash,
        typeHash
    };
    if (ctx.alias)
        attachments.alias = ctx.alias;
    for (const k in inner) {
        if (k !== "description" && k !== "in" && k !== "out")
            attachments[k] = inner[k];
    }
    const node = new nodeClassesByKind[kind](attachments, ctx.$);
    return (nodeCache[innerHash] = node);
};
