var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { CompiledFunction, DynamicBase, ParseError, bound, flatMorph, hasDomain, isArray, printable, throwInternalError, throwParseError } from "@ark/util";
import { resolveConfig } from "./config.js";
import { LazyGenericRoot, parseGeneric } from "./generic.js";
import { nodeImplementationsByKind } from "./kinds.js";
import { RootModule } from "./module.js";
import { parseNode, registerNodeId, schemaKindOf } from "./parse.js";
import { normalizeAliasSchema } from "./roots/alias.js";
import { NodeCompiler } from "./shared/compile.js";
import { arkKind, hasArkKind, isNode } from "./shared/utils.js";
const schemaBranchesOf = (schema) => isArray(schema) ? schema
    : "branches" in schema && isArray(schema.branches) ? schema.branches
        : undefined;
const throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);
export const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;
const scopesById = {};
$ark.intrinsic = {};
let RawRootScope = (() => {
    let _instanceExtraInitializers = [];
    let _schema_decorators;
    let _defineRoot_decorators;
    let _generic_decorators;
    let _units_decorators;
    let _node_decorators;
    return class RawRootScope {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _schema_decorators = [bound];
            _defineRoot_decorators = [bound];
            _generic_decorators = [bound];
            _units_decorators = [bound];
            _node_decorators = [bound];
            __esDecorate(this, null, _schema_decorators, { kind: "method", name: "schema", static: false, private: false, access: { has: obj => "schema" in obj, get: obj => obj.schema }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _defineRoot_decorators, { kind: "method", name: "defineRoot", static: false, private: false, access: { has: obj => "defineRoot" in obj, get: obj => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _generic_decorators, { kind: "method", name: "generic", static: false, private: false, access: { has: obj => "generic" in obj, get: obj => obj.generic }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _units_decorators, { kind: "method", name: "units", static: false, private: false, access: { has: obj => "units" in obj, get: obj => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _node_decorators, { kind: "method", name: "node", static: false, private: false, access: { has: obj => "node" in obj, get: obj => obj.node }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        config = __runInitializers(this, _instanceExtraInitializers);
        resolvedConfig;
        id = `${Object.keys(scopesById).length}$`;
        [arkKind] = "scope";
        referencesById = {};
        references = [];
        resolutions = {};
        json = {};
        exportedNames = [];
        aliases = {};
        resolved = false;
        constructor(
        /** The set of names defined at the root-level of the scope mapped to their
         * corresponding definitions.**/
        def, config) {
            this.config = config ?? {};
            this.resolvedConfig = resolveConfig(config);
            const aliasEntries = Object.entries(def).map(entry => this.preparseAlias(...entry));
            aliasEntries.forEach(([k, v]) => {
                if (k[0] === "#") {
                    const name = k.slice(1);
                    if (name in this.aliases)
                        throwParseError(writeDuplicateAliasError(name));
                    this.aliases[name] = v;
                }
                else {
                    if (k in this.aliases)
                        throwParseError(writeDuplicateAliasError(k));
                    this.aliases[k] = v;
                    this.exportedNames.push(k);
                }
            });
            if ($ark.ambient) {
                // ensure exportedResolutions is populated
                $ark.ambient.export();
                this.resolutions = {};
            }
            scopesById[this.id] = this;
        }
        get internal() {
            return this;
        }
        schema(def, opts) {
            return this.node(schemaKindOf(def), def, opts);
        }
        defineRoot(def) {
            return def;
        }
        generic(params, def) {
            if (def === undefined) {
                return (def) => this.generic(params, new LazyGenericRoot(def));
            }
            return parseGeneric(params, def, this);
        }
        units(values, opts) {
            const uniqueValues = [];
            for (const value of values)
                if (!uniqueValues.includes(value))
                    uniqueValues.push(value);
            const branches = uniqueValues.map(unit => this.node("unit", { unit }, opts));
            return this.node("union", branches, {
                ...opts,
                prereduced: true
            });
        }
        lazyResolutions = [];
        lazilyResolve(resolve, syntheticAlias) {
            const node = this.node("alias", {
                alias: syntheticAlias ?? "synthetic",
                resolve
            }, { prereduced: true });
            if (!this.resolved)
                this.lazyResolutions.push(node);
            return node;
        }
        node(kinds, nodeSchema, opts = {}) {
            let kind = typeof kinds === "string" ? kinds : schemaKindOf(nodeSchema, kinds);
            let schema = nodeSchema;
            if (isNode(schema) && schema.kind === kind)
                return schema.bindScope(this);
            if (kind === "alias" && !opts?.prereduced) {
                const resolution = this.resolveRoot(normalizeAliasSchema(schema).alias);
                schema = resolution;
                kind = resolution.kind;
            }
            else if (kind === "union" && hasDomain(schema, "object")) {
                const branches = schemaBranchesOf(schema);
                if (branches?.length === 1) {
                    schema = branches[0];
                    kind = schemaKindOf(schema);
                }
            }
            const impl = nodeImplementationsByKind[kind];
            const normalizedSchema = impl.normalize?.(schema) ?? schema;
            // check again after normalization in case a node is a valid collapsed
            // schema for the kind (e.g. sequence can collapse to element accepting a Node)
            if (isNode(normalizedSchema)) {
                return normalizedSchema.kind === kind ?
                    normalizedSchema.bindScope(this)
                    : throwMismatchedNodeRootError(kind, normalizedSchema.kind);
            }
            const id = registerNodeId(kind, opts);
            const node = parseNode(id, kind, normalizedSchema, this, opts ?? {}).bindScope(this);
            if (this.resolved) {
                // this node was not part of the original scope, so compile an anonymous scope
                // including only its references
                if (!this.resolvedConfig.jitless)
                    bindCompiledScope(node.references);
            }
            else {
                // we're still parsing the scope itself, so defer compilation but
                // add the node as a reference
                Object.assign(this.referencesById, node.referencesById);
            }
            return node;
        }
        finalizeRootArgs(opts, resolve) {
            const isResolution = opts.alias && opts.alias in this.aliases;
            // if the definition being parsed is not a scope alias and is not a
            // generic instantiation (i.e. opts don't include args), add this as a resolution.
            // TODO: this.lazilyResolve(resolve)
            resolve;
            if (!isResolution)
                opts.args ??= { this: $ark.intrinsic.unknown };
            return opts;
        }
        parseRoot(def, opts = {}) {
            const node = this.schema(def, this.finalizeRootArgs(opts, () => node));
            return node;
        }
        resolveRoot(name) {
            return (this.maybeResolveRoot(name) ??
                throwParseError(writeUnresolvableMessage(name)));
        }
        maybeResolveRoot(name) {
            const result = this.maybeResolveGenericOrRoot(name);
            if (hasArkKind(result, "generic"))
                return;
            return result;
        }
        maybeResolveGenericOrRoot(name) {
            const resolution = this.maybeResolve(name);
            if (hasArkKind(resolution, "module"))
                return throwParseError(writeMissingSubmoduleAccessMessage(name));
            return resolution;
        }
        preparseRoot(def) {
            return def;
        }
        preparseAlias(k, v) {
            return [k, v];
        }
        maybeResolve(name) {
            const resolution = this.maybeShallowResolve(name);
            return typeof resolution === "string" ?
                this.node("alias", { alias: resolution }, { prereduced: true })
                : resolution;
        }
        maybeShallowResolve(name) {
            const cached = this.resolutions[name];
            if (cached)
                return cached;
            const def = this.aliases[name] ?? $ark.ambient?.resolutions[name];
            if (!def)
                return this.maybeResolveSubalias(name);
            const preparsed = this.preparseRoot(def);
            if (hasArkKind(preparsed, "generic")) {
                return (this.resolutions[name] = preparsed
                    .validateBaseInstantiation()
                    ?.bindScope(this));
            }
            if (hasArkKind(preparsed, "module")) {
                return (this.resolutions[name] = new RootModule(flatMorph(preparsed, (alias, node) => [
                    alias,
                    node.bindScope(this)
                ])));
            }
            this.resolutions[name] = name;
            return (this.resolutions[name] = this.parseRoot(preparsed, {
                alias: name
            }).bindScope(this));
        }
        /** If name is a valid reference to a submodule alias, return its resolution  */
        maybeResolveSubalias(name) {
            return maybeResolveSubalias(this.aliases, name);
        }
        import(...names) {
            return new RootModule(flatMorph(this.export(...names), (alias, value) => [
                `#${alias}`,
                value
            ]));
        }
        _exportedResolutions;
        _exports;
        export(...names) {
            if (!this._exports) {
                this._exports = {};
                for (const name of this.exportedNames) {
                    const resolution = this.maybeResolve(name);
                    if (hasArkKind(resolution, "root")) {
                        resolution.references
                            .filter(node => node.hasKind("alias"))
                            .forEach(aliasNode => {
                            Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);
                            resolution.references.forEach(ref => {
                                if (aliasNode.id in ref.referencesById)
                                    Object.assign(ref.referencesById, aliasNode.referencesById);
                            });
                        });
                    }
                    this._exports[name] = resolution;
                }
                this.lazyResolutions.forEach(node => node.resolution);
                this._exportedResolutions = resolutionsOfModule(this, this._exports);
                // TODO: add generic json
                Object.assign(this.json, flatMorph(this._exportedResolutions, (k, v) => hasArkKind(v, "root") ? [k, v.json] : []));
                Object.assign(this.resolutions, this._exportedResolutions);
                if (this.config.intrinsic)
                    Object.assign($ark.intrinsic, this._exportedResolutions);
                this.references = Object.values(this.referencesById);
                if (!this.resolvedConfig.jitless)
                    bindCompiledScope(this.references);
                this.resolved = true;
            }
            const namesToExport = names.length ? names : this.exportedNames;
            return new RootModule(flatMorph(namesToExport, (_, name) => [
                name,
                this._exports[name]
            ]));
        }
        resolve(name) {
            return this.export()[name];
        }
    };
})();
export { RawRootScope };
const maybeResolveSubalias = (base, name) => {
    const dotIndex = name.indexOf(".");
    if (dotIndex === -1)
        return;
    const dotPrefix = name.slice(0, dotIndex);
    const prefixSchema = base[dotPrefix];
    // if the name includes ".", but the prefix is not an alias, it
    // might be something like a decimal literal, so just fall through to return
    if (prefixSchema === undefined)
        return;
    if (!hasArkKind(prefixSchema, "module"))
        return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));
    const subalias = name.slice(dotIndex + 1);
    const resolution = prefixSchema[subalias];
    if (resolution === undefined)
        return;
    if (hasArkKind(resolution, "module"))
        return maybeResolveSubalias(resolution, subalias);
    if (hasArkKind(resolution, "root") || hasArkKind(resolution, "generic"))
        return resolution;
    throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);
};
export const schemaScope = (aliases, config) => new RootScope(aliases, config);
export const RootScope = RawRootScope;
export const root = new RootScope({});
export const schema = root.schema;
export const node = root.node;
export const defineRoot = root.defineRoot;
export const units = root.units;
export const generic = root.generic;
export const internalSchema = root.internal.schema;
export const internalNode = root.internal.node;
export const defineInternalRoot = root.internal.defineRoot;
export const internalUnits = root.internal.units;
export const internalGeneric = root.internal.generic;
export const parseAsSchema = (def, opts) => {
    try {
        return schema(def, opts);
    }
    catch (e) {
        if (e instanceof ParseError)
            return e;
        throw e;
    }
};
export class RawRootModule extends DynamicBase {
}
const resolutionsOfModule = ($, typeSet) => {
    const result = {};
    for (const k in typeSet) {
        const v = typeSet[k];
        if (hasArkKind(v, "module")) {
            const innerResolutions = resolutionsOfModule($, v);
            const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);
            Object.assign(result, prefixedResolutions);
        }
        else if (hasArkKind(v, "generic"))
            result[k] = v;
        else if (hasArkKind(v, "root"))
            result[k] = v;
        else
            throwInternalError(`Unexpected scope resolution ${printable(v)}`);
    }
    return result;
};
export const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;
export const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;
export const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;
export const bindCompiledScope = (references) => {
    const compiledTraversals = compileScope(references);
    for (const node of references) {
        if (node.jit) {
            // if node has already been bound to another scope or anonymous type, don't rebind it
            continue;
        }
        node.jit = true;
        node.traverseAllows =
            compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);
        if (node.isRoot() && !node.allowsRequiresContext) {
            // if the reference doesn't require context, we can assign over
            // it directly to avoid having to initialize it
            node.allows = node.traverseAllows;
        }
        node.traverseApply =
            compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);
    }
};
const compileScope = (references) => new CompiledFunction()
    .block("return", js => {
    references.forEach(node => {
        const allowsCompiler = new NodeCompiler("Allows").indent();
        node.compile(allowsCompiler);
        const applyCompiler = new NodeCompiler("Apply").indent();
        node.compile(applyCompiler);
        js.line(`${allowsCompiler.writeMethod(`${node.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node.id}Apply`)},`);
    });
    return js;
})
    .compile()();
