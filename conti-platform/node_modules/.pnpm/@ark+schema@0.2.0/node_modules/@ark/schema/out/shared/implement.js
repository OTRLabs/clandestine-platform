import { compileSerializedValue, flatMorph, printable, throwParseError } from "@ark/util";
import { isNode } from "./utils.js";
export const basisKinds = ["unit", "proto", "domain"];
export const structuralKinds = [
    "required",
    "optional",
    "index",
    "sequence"
];
export const refinementKinds = [
    "pattern",
    "divisor",
    "exactLength",
    "max",
    "min",
    "maxLength",
    "minLength",
    "before",
    "after"
];
export const constraintKinds = [
    ...refinementKinds,
    ...structuralKinds,
    "structure",
    "predicate"
];
export const rootKinds = [
    "alias",
    "union",
    "morph",
    "unit",
    "intersection",
    "proto",
    "domain"
];
export const nodeKinds = [...rootKinds, ...constraintKinds];
export const constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);
export const structureKeys = flatMorph([...structuralKinds, "undeclared"], (i, k) => [k, 1]);
export const precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);
export const isNodeKind = (value) => typeof value === "string" && value in precedenceByKind;
export function assertNodeKind(value, kind) {
    const valueIsNode = isNode(value);
    if (!valueIsNode || value.kind !== kind) {
        throwParseError(`Expected node of kind ${kind} (was ${valueIsNode ? `${value.kind} node` : printable(value)})`);
    }
}
export const precedenceOfKind = (kind) => precedenceByKind[kind];
export const schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);
export const defaultValueSerializer = (v) => {
    if (typeof v === "string" ||
        typeof v === "boolean" ||
        typeof v === "number" ||
        v === null)
        return v;
    return compileSerializedValue(v);
};
export const compileErrorContext = (ctx) => {
    let result = "{ ";
    for (const [k, v] of Object.entries(ctx))
        result += `${k}: ${compileSerializedValue(v)}, `;
    return result + " }";
};
export const baseKeys = {
    description: { meta: true }
};
export const implementNode = (_) => {
    const implementation = _;
    if (implementation.hasAssociatedError) {
        implementation.defaults.expected ??= ctx => "description" in ctx ?
            ctx.description
            : implementation.defaults.description(ctx);
        implementation.defaults.actual ??= data => printable(data);
        implementation.defaults.problem ??= ctx => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : ""}`;
        implementation.defaults.message ??= ctx => {
            if (ctx.path.length === 0)
                return ctx.problem;
            const problemWithLocation = `${ctx.propString} ${ctx.problem}`;
            if (problemWithLocation[0] === "[") {
                // clarify paths like [1], [0][1], and ["key!"] that could be confusing
                return `value at ${problemWithLocation}`;
            }
            return problemWithLocation;
        };
    }
    Object.assign(implementation.keys, baseKeys);
    return implementation;
};
