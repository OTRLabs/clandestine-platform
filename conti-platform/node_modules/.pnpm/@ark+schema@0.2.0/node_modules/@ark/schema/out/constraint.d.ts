import { type array, type describe, type listable, type satisfy } from "@ark/util";
import type { Inner, Node, NodeSchema, Prerequisite, innerAttachedAs } from "./kinds.js";
import { BaseNode } from "./node.js";
import type { NodeParseContext } from "./parse.js";
import type { IntersectionInner, MutableIntersectionInner } from "./roots/intersection.js";
import type { BaseRoot, Root, UnknownRoot } from "./roots/root.js";
import type { NodeCompiler } from "./shared/compile.js";
import type { RawNodeDeclaration } from "./shared/declare.js";
import { Disjoint } from "./shared/disjoint.js";
import { type ConstraintKind, type IntersectionContext, type NodeKind, type RootKind, type StructuralKind, type kindLeftOf } from "./shared/implement.js";
import type { TraverseAllows, TraverseApply } from "./shared/traversal.js";
import { arkKind } from "./shared/utils.js";
export interface BaseConstraintDeclaration extends RawNodeDeclaration {
    kind: ConstraintKind;
}
export declare abstract class BaseConstraint<
/** uses -ignore rather than -expect-error because this is not an error in .d.ts
 * @ts-ignore allow instantiation assignment to the base type */
out d extends BaseConstraintDeclaration = BaseConstraintDeclaration> extends BaseNode<d> {
    readonly [arkKind] = "constraint";
    abstract readonly impliedBasis: BaseRoot | null;
    readonly impliedSiblings?: array<BaseConstraint>;
    intersect<r extends BaseConstraint>(r: r): intersectConstraintKinds<d["kind"], r["kind"]>;
}
export type ConstraintReductionResult = BaseRoot | Disjoint | MutableIntersectionInner;
export declare abstract class RawPrimitiveConstraint<d extends BaseConstraintDeclaration> extends BaseConstraint<d> {
    abstract traverseAllows: TraverseAllows<d["prerequisite"]>;
    abstract readonly compiledCondition: string;
    abstract readonly compiledNegation: string;
    traverseApply: TraverseApply<d["prerequisite"]>;
    compile(js: NodeCompiler): void;
    get errorContext(): d["errorContext"];
    get compiledErrorContext(): string;
}
export declare const constraintKeyParser: <kind extends ConstraintKind>(kind: kind) => (schema: listable<NodeSchema<kind>>, ctx: NodeParseContext) => innerAttachedAs<kind> | undefined;
type ConstraintGroupKind = satisfy<NodeKind, "intersection" | "structure">;
interface ConstraintIntersectionState<kind extends ConstraintGroupKind = ConstraintGroupKind> {
    kind: kind;
    baseInner: Record<string, unknown>;
    l: BaseConstraint[];
    r: BaseConstraint[];
    roots: BaseRoot[];
    ctx: IntersectionContext;
}
export declare const intersectConstraints: <kind extends ConstraintGroupKind>(s: ConstraintIntersectionState<kind>) => Node<RootKind | Extract<kind, "structure">> | Disjoint;
export declare const flattenConstraints: (inner: object) => BaseConstraint[];
export declare const unflattenConstraints: (constraints: array<BaseConstraint>) => IntersectionInner & Inner<"structure">;
export type constraintKindLeftOf<kind extends ConstraintKind> = ConstraintKind & kindLeftOf<kind>;
export type constraintKindOrLeftOf<kind extends ConstraintKind> = kind | constraintKindLeftOf<kind>;
export type intersectConstraintKinds<l extends ConstraintKind, r extends ConstraintKind> = Node<l | r | "unit" | "union"> | Disjoint | null;
export declare const throwInvalidOperandError: (kind: "pattern" | "divisor" | "exactLength" | "max" | "min" | "maxLength" | "minLength" | "before" | "after" | "required" | "optional" | "index" | "sequence" | "structure" | "predicate", expected: Root<unknown, any>, actual: Root<unknown, any>) => never;
export declare const writeInvalidOperandMessage: <kind extends ConstraintKind, expected extends Root, actual extends Root>(kind: kind, expected: expected, actual: actual) => writeInvalidOperandMessage<kind, actual>;
export type writeInvalidOperandMessage<kind extends ConstraintKind, actual extends Root> = `${Capitalize<kind>} operand must be ${describe<Prerequisite<kind>>} (was ${describe<Exclude<actual["infer"], Prerequisite<kind>>>})`;
export interface ConstraintAttachments {
    impliedBasis: UnknownRoot | null;
    impliedSiblings?: array<BaseConstraint> | null;
}
export type PrimitiveConstraintKind = Exclude<ConstraintKind, StructuralKind>;
export {};
