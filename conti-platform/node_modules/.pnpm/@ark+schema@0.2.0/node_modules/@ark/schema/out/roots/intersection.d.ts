import { type array, type listable, type show } from "@ark/util";
import type { Inner, MutableInner, Node, NodeSchema, Prerequisite } from "../kinds.js";
import type { PredicateNode } from "../predicate.js";
import type { NodeCompiler } from "../shared/compile.js";
import { type BaseMeta, type declareNode } from "../shared/declare.js";
import type { ArkError } from "../shared/errors.js";
import { type ConstraintKind, type OpenNodeKind, type RefinementKind, type StructuralKind, type nodeImplementationOf } from "../shared/implement.js";
import type { TraverseAllows, TraverseApply } from "../shared/traversal.js";
import type { StructureNode, UndeclaredKeyBehavior } from "../structure/structure.js";
import type { DomainNode, DomainSchema } from "./domain.js";
import type { ProtoNode, ProtoSchema } from "./proto.js";
import { BaseRoot } from "./root.js";
export type IntersectionBasisKind = "domain" | "proto";
export type IntersectionChildKind = IntersectionBasisKind | ConstraintKind;
export type RefinementsInner = {
    [k in RefinementKind]?: intersectionChildInnerValueOf<k>;
};
export interface IntersectionInner extends BaseMeta, RefinementsInner {
    domain?: DomainNode;
    proto?: ProtoNode;
    structure?: StructureNode;
    predicate?: array<PredicateNode>;
}
export type MutableIntersectionInner = MutableInner<"intersection">;
export type NormalizedIntersectionSchema = Omit<IntersectionSchema, StructuralKind | "undeclared">;
export type IntersectionSchema<inferredBasis = any> = show<BaseMeta & {
    domain?: DomainSchema;
    proto?: ProtoSchema;
} & conditionalRootOf<inferredBasis>>;
export type IntersectionDeclaration = declareNode<{
    kind: "intersection";
    schema: IntersectionSchema;
    normalizedSchema: NormalizedIntersectionSchema;
    inner: IntersectionInner;
    reducibleTo: "intersection" | IntersectionBasisKind;
    errorContext: {
        errors: readonly ArkError[];
    };
    childKind: IntersectionChildKind;
}>;
export declare class IntersectionNode extends BaseRoot<IntersectionDeclaration> {
    basis: Node<IntersectionBasisKind> | null;
    refinements: array<Node<RefinementKind>>;
    expression: string;
    get shortDescription(): string;
    traverseAllows: TraverseAllows;
    traverseApply: TraverseApply;
    compile(js: NodeCompiler): void;
    rawKeyOf(): BaseRoot;
}
export declare const intersectionImplementation: nodeImplementationOf<IntersectionDeclaration>;
export type ConditionalTerminalIntersectionRoot = {
    undeclared?: UndeclaredKeyBehavior;
};
type ConditionalTerminalIntersectionKey = keyof ConditionalTerminalIntersectionRoot;
type ConditionalIntersectionKey = ConstraintKind | ConditionalTerminalIntersectionKey;
export type constraintKindOf<t> = {
    [k in ConstraintKind]: t extends Prerequisite<k> ? k : never;
}[ConstraintKind];
type conditionalIntersectionKeyOf<t> = constraintKindOf<t> | (t extends object ? "undeclared" : never);
type intersectionChildRootValueOf<k extends IntersectionChildKind> = k extends OpenNodeKind ? listable<NodeSchema<k> | Inner<k>> : NodeSchema<k> | Inner<k>;
type conditionalRootValueOfKey<k extends ConditionalIntersectionKey> = k extends IntersectionChildKind ? intersectionChildRootValueOf<k> : ConditionalTerminalIntersectionRoot[k & ConditionalTerminalIntersectionKey];
type intersectionChildInnerValueOf<k extends IntersectionChildKind> = k extends OpenNodeKind ? readonly Node<k>[] : Node<k>;
export type conditionalRootOf<t> = {
    [k in conditionalIntersectionKeyOf<t>]?: conditionalRootValueOfKey<k>;
};
export {};
