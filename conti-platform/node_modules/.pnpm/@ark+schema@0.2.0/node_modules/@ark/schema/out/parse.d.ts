import type { GenericArgResolutions } from "./generic.js";
import { type NormalizedSchema } from "./kinds.js";
import type { BaseNode } from "./node.js";
import type { RawRootScope } from "./scope.js";
import { type NodeKind, type RootKind } from "./shared/implement.js";
export type NodeParseOptions<prereduced extends boolean = boolean> = {
    alias?: string;
    prereduced?: prereduced;
    /** Instead of creating the node, compute the innerHash of the definition and
     * point it to the specified resolution.
     *
     * Useful for defining reductions like number|string|bigint|symbol|object|true|false|null|undefined => unknown
     **/
    reduceTo?: BaseNode;
    args?: GenericArgResolutions;
};
export interface NodeParseContext<kind extends NodeKind = NodeKind> extends NodeParseOptions {
    $: RawRootScope;
    args: GenericArgResolutions;
    schema: NormalizedSchema<kind>;
    id: string;
}
export declare const schemaKindOf: <kind extends RootKind = "alias" | "union" | "morph" | "unit" | "intersection" | "proto" | "domain">(schema: unknown, allowedKinds?: readonly kind[]) => kind;
export declare const writeInvalidSchemaMessage: (schema: unknown) => string;
export declare const registerNodeId: (kind: NodeKind, opts: NodeParseOptions) => string;
export declare const parseNode: <kind extends NodeKind>(id: string, kind: kind, schema: NormalizedSchema<kind>, $: RawRootScope, opts: NodeParseOptions) => BaseNode;
