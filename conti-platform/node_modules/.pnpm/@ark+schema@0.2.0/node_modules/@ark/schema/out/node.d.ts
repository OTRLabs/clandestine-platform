import { Callable, type Guardable, type Json, type Key, type array, type conform, type listable, type mutable } from "@ark/util";
import type { BaseConstraint } from "./constraint.js";
import type { Inner, Node, reducibleKindOf } from "./kinds.js";
import type { NodeParseOptions } from "./parse.js";
import type { MorphNode } from "./roots/morph.js";
import type { BaseRoot, Root } from "./roots/root.js";
import type { UnitNode } from "./roots/unit.js";
import type { RawRootScope } from "./scope.js";
import type { NodeCompiler } from "./shared/compile.js";
import type { BaseMeta, RawNodeDeclaration, attachmentsOf } from "./shared/declare.js";
import { type BasisKind, type NodeKind, type OpenNodeKind, type RefinementKind, type StructuralKind, type UnknownAttachments } from "./shared/implement.js";
import { type TraverseAllows, type TraverseApply } from "./shared/traversal.js";
import { type arkKind } from "./shared/utils.js";
export type UnknownNode = BaseNode | Root;
export declare abstract class BaseNode<
/** uses -ignore rather than -expect-error because this is not an error in .d.ts
 * @ts-ignore allow instantiation assignment to the base type */
out d extends RawNodeDeclaration = RawNodeDeclaration> extends Callable<(data: d["prerequisite"]) => unknown, attachmentsOf<d>> {
    attachments: UnknownAttachments;
    $: RawRootScope;
    constructor(attachments: UnknownAttachments, $: RawRootScope);
    bindScope($: RawRootScope): this;
    abstract traverseAllows: TraverseAllows<d["prerequisite"]>;
    abstract traverseApply: TraverseApply<d["prerequisite"]>;
    abstract expression: string;
    abstract compile(js: NodeCompiler): void;
    readonly includesMorph: boolean;
    readonly allowsRequiresContext: boolean;
    readonly referencesById: Record<string, BaseNode>;
    get description(): string;
    get references(): BaseNode[];
    get shallowReferences(): BaseNode[];
    get shallowMorphs(): MorphNode[];
    get flatRefs(): array<FlatRef>;
    readonly precedence: number;
    jit: boolean;
    allows: (data: d["prerequisite"]) => boolean;
    traverse(data: d["prerequisite"]): unknown;
    get in(): this extends {
        [arkKind]: "root";
    } ? BaseRoot : BaseNode;
    get out(): this extends {
        [arkKind]: "root";
    } ? BaseRoot : BaseNode;
    getIo(kind: "in" | "out"): BaseNode;
    toJSON(): Json;
    toString(): string;
    equals(other: UnknownNode): boolean;
    assertHasKind<kind extends NodeKind>(kind: kind): Node<kind>;
    hasKind<kind extends NodeKind>(kind: kind): this is Node<kind>;
    isBasis(): this is Node<BasisKind>;
    isConstraint(): this is BaseConstraint;
    isStructural(): this is Node<StructuralKind>;
    isRefinement(): this is Node<RefinementKind>;
    isRoot(): this is BaseRoot;
    hasUnit<value>(value: unknown): this is UnitNode & {
        unit: value;
    };
    hasOpenIntersection(): this is Node<OpenNodeKind>;
    get nestableExpression(): string;
    firstReference<narrowed>(filter: Guardable<BaseNode, conform<narrowed, BaseNode>>): narrowed | undefined;
    firstReferenceOrThrow<narrowed extends BaseNode>(filter: Guardable<BaseNode, narrowed>): narrowed;
    firstReferenceOfKind<kind extends NodeKind>(kind: kind): Node<kind> | undefined;
    firstReferenceOfKindOrThrow<kind extends NodeKind>(kind: kind): Node<kind>;
    transform<mapper extends DeepNodeTransformation>(mapper: mapper, opts?: DeepNodeTransformOptions): Node<reducibleKindOf<this["kind"]>> | Extract<ReturnType<mapper>, null>;
    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformContext): BaseNode | null;
    configureShallowDescendants(configOrDescription: BaseMeta | string): this;
}
/** a literal key (named property) or a node (index signatures) representing part of a type structure */
export type TypeKey = Key | BaseRoot;
export type TypePath = array<TypeKey>;
export type FlatRef<root extends BaseRoot = BaseRoot> = {
    path: TypePath;
    node: root;
    propString: string;
};
export declare const typePathToPropString: (path: Readonly<TypePath>) => string;
export declare const flatRef: <node extends BaseRoot>(path: TypePath, node: node) => FlatRef<node>;
export declare const flatRefsAreEqual: (l: FlatRef, r: FlatRef) => boolean;
export declare const appendUniqueFlatRefs: <node extends BaseRoot>(existing: FlatRef<node>[] | undefined, refs: listable<FlatRef<node>>) => FlatRef<node>[];
export declare const appendUniqueNodes: <node extends BaseNode>(existing: node[] | undefined, refs: listable<node>) => node[];
export type DeepNodeTransformOptions = {
    shouldTransform?: ShouldTransformFn;
    bindScope?: RawRootScope;
    prereduced?: boolean;
};
export type ShouldTransformFn = (node: BaseNode, ctx: DeepNodeTransformContext) => boolean;
export interface DeepNodeTransformContext extends DeepNodeTransformOptions {
    path: mutable<TypePath>;
    seen: {
        [originalId: string]: (() => BaseNode | undefined) | undefined;
    };
    parseOptions: NodeParseOptions;
}
export type DeepNodeTransformation = <kind extends NodeKind>(kind: kind, inner: Inner<kind>, ctx: DeepNodeTransformContext) => Inner<kind> | null;
