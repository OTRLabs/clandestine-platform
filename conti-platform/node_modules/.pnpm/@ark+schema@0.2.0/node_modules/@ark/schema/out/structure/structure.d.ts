import { type array, type Key, type RegisteredReference } from "@ark/util";
import { BaseConstraint } from "../constraint.js";
import type { NonNegativeIntegerString } from "../keywords/internal.js";
import type { TypeKey, TypePath } from "../node.js";
import type { BaseRoot } from "../roots/root.js";
import type { RawRootScope } from "../scope.js";
import type { NodeCompiler } from "../shared/compile.js";
import type { BaseMeta, declareNode } from "../shared/declare.js";
import { type nodeImplementationOf, type StructuralKind } from "../shared/implement.js";
import type { TraversalContext, TraversalKind, TraverseAllows, TraverseApply } from "../shared/traversal.js";
import type { IndexNode, IndexSchema } from "./indexed.js";
import type { OptionalNode, OptionalSchema } from "./optional.js";
import type { PropNode } from "./prop.js";
import type { RequiredNode, RequiredSchema } from "./required.js";
import type { SequenceNode, SequenceSchema } from "./sequence.js";
export type UndeclaredKeyBehavior = "ignore" | UndeclaredKeyHandling;
export type UndeclaredKeyHandling = "reject" | "delete";
export interface StructureSchema extends BaseMeta {
    readonly optional?: readonly OptionalSchema[];
    readonly required?: readonly RequiredSchema[];
    readonly index?: readonly IndexSchema[];
    readonly sequence?: SequenceSchema;
    readonly undeclared?: UndeclaredKeyBehavior;
}
export interface StructureInner extends BaseMeta {
    readonly optional?: readonly OptionalNode[];
    readonly required?: readonly RequiredNode[];
    readonly index?: readonly IndexNode[];
    readonly sequence?: SequenceNode;
    readonly undeclared?: UndeclaredKeyHandling;
}
export interface StructureDeclaration extends declareNode<{
    kind: "structure";
    schema: StructureSchema;
    normalizedSchema: StructureSchema;
    inner: StructureInner;
    prerequisite: object;
    childKind: StructuralKind;
}> {
}
export declare class StructureNode extends BaseConstraint<StructureDeclaration> {
    impliedBasis: BaseRoot;
    impliedSiblings: BaseConstraint<import("../constraint.js").BaseConstraintDeclaration>[];
    props: array<PropNode>;
    propsByKey: Record<Key, PropNode | undefined>;
    propsByKeyReference: RegisteredReference;
    expression: string;
    requiredLiteralKeys: Key[];
    optionalLiteralKeys: Key[];
    literalKeys: Key[];
    keyof(): BaseRoot;
    get(key: TypeKey, ...tail: TypePath): BaseRoot;
    readonly exhaustive: boolean;
    omit(...keys: array<BaseRoot | Key>): StructureNode;
    merge(r: StructureNode): StructureNode;
    traverseAllows: TraverseAllows<object>;
    traverseApply: TraverseApply<object>;
    protected _traverse: (traversalKind: TraversalKind, data: object, ctx: TraversalContext) => boolean;
    compile(js: NodeCompiler): void;
    protected compileExhaustiveEntry(js: NodeCompiler): NodeCompiler;
}
export declare const structureImplementation: nodeImplementationOf<StructureDeclaration>;
export declare const writeRawNumberIndexMessage: (indexExpression: string, sequenceExpression: string) => string;
export declare const writeBadKeyAccessMessage: (key: TypeKey, structuralExpression: string) => string;
export type NormalizedIndex = {
    index?: IndexNode;
    required?: RequiredNode[];
};
/** extract enumerable named props from an index signature */
export declare const normalizeIndex: (signature: BaseRoot, value: BaseRoot, $: RawRootScope) => NormalizedIndex;
export type indexOf<o> = o extends array ? (number extends o["length"] ? NonNegativeIntegerString : never) | {
    [k in keyof o]-?: k extends `${infer index extends number}` ? index | k : never;
}[keyof o & `${number}`] : {
    [k in keyof o]: k extends number ? k | `${k}` : k;
}[keyof o];
export type indexInto<o, k extends indexOf<o>> = o[Extract<k extends NonNegativeIntegerString ? number : k, keyof o>];
