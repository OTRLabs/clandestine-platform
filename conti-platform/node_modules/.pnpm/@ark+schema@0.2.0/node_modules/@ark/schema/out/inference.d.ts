import type { Constructor, ErrorMessage, NonEnumerableDomain, array, conform, inferDomain, instanceOf, isAny, typeToString } from "@ark/util";
import type { NodeSchema, Prerequisite } from "./kinds.js";
import type { BaseNode } from "./node.js";
import type { DomainSchema } from "./roots/domain.js";
import type { IntersectionSchema } from "./roots/intersection.js";
import type { Morph, MorphChildSchema, MorphSchema, Out, inferMorphOut } from "./roots/morph.js";
import type { ProtoSchema } from "./roots/proto.js";
import type { NormalizedUnionSchema, UnionSchema } from "./roots/union.js";
import type { UnitSchema } from "./roots/unit.js";
import type { ArkErrors } from "./shared/errors.js";
import type { BasisKind, ConstraintKind } from "./shared/implement.js";
import type { inferred } from "./shared/utils.js";
export declare namespace type {
    type cast<t> = {
        [inferred]?: t;
    };
    type errors = ArkErrors;
}
export type validateRoot<schema, $> = schema extends type.cast<unknown> ? schema : schema extends array ? {
    [i in keyof schema]: validateRootBranch<schema[i], $>;
} : schema extends NormalizedUnionSchema<infer branches> ? conform<schema, NormalizedUnionSchema & {
    branches: {
        [i in keyof branches]: validateRootBranch<branches[i], $>;
    };
}> : validateRootBranch<schema, $>;
export type inferRoot<schema, $> = schema extends type.cast<infer to> ? to : schema extends UnionSchema<infer branches> ? branches["length"] extends 0 ? never : branches["length"] extends 1 ? inferRootBranch<branches[0], $> : inferRootBranch<branches[number], $> : inferRootBranch<schema, $>;
type validateRootBranch<schema, $> = schema extends BaseNode ? schema : "morphs" extends keyof schema ? validateMorphRoot<schema, $> : validateMorphChild<schema, $>;
type inferRootBranch<schema, $> = schema extends type.cast<infer to> ? to : schema extends MorphSchema ? (In: schema["in"] extends {} ? inferMorphChild<schema["in"], $> : unknown) => schema["morphs"] extends infer morph extends Morph ? Out<inferMorphOut<morph>> : schema["morphs"] extends (readonly [...unknown[], infer morph extends Morph]) ? Out<inferMorphOut<morph>> : never : schema extends MorphChildSchema ? inferMorphChild<schema, $> : unknown;
type NonIntersectableBasisRoot = NonEnumerableDomain | Constructor | UnitSchema;
type validateMorphChild<schema, $> = [
    schema
] extends [NonIntersectableBasisRoot] ? schema : validateIntersectionRoot<schema, $>;
type inferMorphChild<schema, $> = schema extends NonIntersectableBasisRoot ? inferBasis<schema, $> : schema extends IntersectionSchema ? inferBasisOf<schema, $> : unknown;
type validateMorphRoot<schema, $> = {
    [k in keyof schema]: k extends "from" | "to" ? validateMorphChild<schema[k], $> : k extends keyof MorphSchema ? MorphSchema[k] : `'${k & string}' is not a valid morph schema key`;
};
type exactBasisMessageOnError<schema, expected> = {
    [k in keyof schema]: k extends keyof expected ? conform<schema[k], expected[k]> : ErrorMessage<k extends ConstraintKind ? `${k} has a prerequisite of ${typeToString<Prerequisite<k>>}` : `'${k & string}' is not on an intersection schema`>;
};
export type validateIntersectionRoot<schema, $> = exactBasisMessageOnError<schema, IntersectionSchema<inferBasisOf<schema, $>>>;
type inferBasisOf<schema, $> = "proto" extends keyof schema ? inferBasis<conform<schema["proto"], ProtoSchema>, $> : "domain" extends keyof schema ? inferBasis<conform<schema["domain"], DomainSchema>, $> : unknown;
export type inferBasis<schema extends NodeSchema<BasisKind>, $> = isAny<schema> extends (true) ? any : schema extends NonEnumerableDomain ? inferDomain<schema> : schema extends Constructor<infer instance> ? instance : schema extends DomainSchema<infer domain> ? inferDomain<domain> : schema extends ProtoSchema<infer proto> ? instanceOf<proto> : schema extends UnitSchema<infer is> ? is : never;
export {};
