import { type Domain, type Json, type Key, type SerializedPrimitive, type show } from "@ark/util";
import type { Node, NodeSchema } from "../kinds.js";
import type { NodeCompiler } from "../shared/compile.js";
import type { BaseMeta, declareNode } from "../shared/declare.js";
import { Disjoint } from "../shared/disjoint.js";
import type { ArkError } from "../shared/errors.js";
import { type IntersectionContext, type RootKind, type nodeImplementationOf } from "../shared/implement.js";
import type { TraverseAllows, TraverseApply } from "../shared/traversal.js";
import type { MorphNode } from "./morph.js";
import { BaseRoot, type schemaKindRightOf } from "./root.js";
import type { UnitNode } from "./unit.js";
export type UnionChildKind = schemaKindRightOf<"union"> | "alias";
export type UnionChildSchema = NodeSchema<UnionChildKind>;
export type UnionChildNode = Node<UnionChildKind>;
export type UnionSchema<branches extends readonly UnionChildSchema[] = readonly UnionChildSchema[]> = NormalizedUnionSchema<branches> | branches;
export interface NormalizedUnionSchema<branches extends readonly UnionChildSchema[] = readonly UnionChildSchema[]> extends BaseMeta {
    readonly branches: branches;
    readonly ordered?: true;
}
export interface UnionInner extends BaseMeta {
    readonly branches: readonly UnionChildNode[];
    readonly ordered?: true;
}
export interface UnionDeclaration extends declareNode<{
    kind: "union";
    schema: UnionSchema;
    normalizedSchema: NormalizedUnionSchema;
    inner: UnionInner;
    errorContext: {
        errors: readonly ArkError[];
    };
    reducibleTo: RootKind;
    childKind: UnionChildKind;
}> {
}
export declare const unionImplementation: nodeImplementationOf<UnionDeclaration>;
export declare class UnionNode extends BaseRoot<UnionDeclaration> {
    isNever: boolean;
    isBoolean: boolean;
    unitBranches: (MorphNode | UnitNode)[];
    discriminant: Discriminant<DiscriminantKind> | null;
    discriminantJson: Json | null;
    expression: string;
    get shortDescription(): string;
    traverseAllows: TraverseAllows;
    traverseApply: TraverseApply;
    compile(js: NodeCompiler): void;
    private compileIndiscriminable;
    rawKeyOf(): BaseRoot;
    get nestableExpression(): string;
    discriminate(): Discriminant | null;
}
export declare const intersectBranches: (l: readonly UnionChildNode[], r: readonly UnionChildNode[], ctx: IntersectionContext) => readonly UnionChildNode[] | Disjoint;
export declare const reduceBranches: ({ branches, ordered }: UnionInner) => readonly UnionChildNode[];
export type CaseKey<kind extends DiscriminantKind = DiscriminantKind> = DiscriminantKind extends kind ? string : DiscriminantKinds[kind] | "default";
type DiscriminantContext<kind extends DiscriminantKind = DiscriminantKind> = {
    path: Key[];
    propString: string;
    kind: kind;
};
export interface Discriminant<kind extends DiscriminantKind = DiscriminantKind> extends DiscriminantContext<kind> {
    cases: DiscriminatedCases<kind>;
}
export type DiscriminatedCases<kind extends DiscriminantKind = DiscriminantKind> = {
    [caseKey in CaseKey<kind>]: BaseRoot | true;
};
export type DiscriminantKinds = {
    domain: Domain;
    unit: SerializedPrimitive;
};
export type DiscriminantKind = show<keyof DiscriminantKinds>;
export declare const pruneDiscriminant: (discriminantBranch: BaseRoot, discriminantCtx: DiscriminantContext) => BaseRoot | null;
export declare const writeIndiscriminableMorphMessage: (lDescription: string, rDescription: string) => string;
export declare const writeOrderedIntersectionMessage: (lDescription: string, rDescription: string) => string;
export {};
