import { type array, type listable } from "@ark/util";
import type { BaseNode } from "./node.js";
import { PredicateNode, type PredicateDeclaration } from "./predicate.js";
import { DivisorNode, type DivisorDeclaration } from "./refinements/divisor.js";
import { type BoundDeclarations, type BoundNodesByKind } from "./refinements/kinds.js";
import { PatternNode, type PatternDeclaration } from "./refinements/pattern.js";
import { AliasNode, type AliasDeclaration } from "./roots/alias.js";
import { DomainNode, type DomainDeclaration } from "./roots/domain.js";
import { IntersectionNode, type IntersectionDeclaration } from "./roots/intersection.js";
import { MorphNode, type MorphDeclaration } from "./roots/morph.js";
import { ProtoNode, type ProtoDeclaration } from "./roots/proto.js";
import { UnionNode, type UnionDeclaration } from "./roots/union.js";
import { UnitNode, type UnitDeclaration } from "./roots/unit.js";
import type { RawRootScope } from "./scope.js";
import type { ConstraintKind, NodeKind, OpenNodeKind, RootKind, UnknownAttachments, UnknownNodeImplementation } from "./shared/implement.js";
import type { makeRootAndArrayPropertiesMutable } from "./shared/utils.js";
import { IndexNode, type IndexDeclaration } from "./structure/indexed.js";
import { OptionalNode, type OptionalDeclaration } from "./structure/optional.js";
import { RequiredNode, type RequiredDeclaration } from "./structure/required.js";
import { SequenceNode, type SequenceDeclaration } from "./structure/sequence.js";
import { StructureNode, type StructureDeclaration } from "./structure/structure.js";
export interface NodeDeclarationsByKind extends BoundDeclarations {
    alias: AliasDeclaration;
    domain: DomainDeclaration;
    unit: UnitDeclaration;
    proto: ProtoDeclaration;
    union: UnionDeclaration;
    morph: MorphDeclaration;
    intersection: IntersectionDeclaration;
    sequence: SequenceDeclaration;
    divisor: DivisorDeclaration;
    required: RequiredDeclaration;
    optional: OptionalDeclaration;
    index: IndexDeclaration;
    pattern: PatternDeclaration;
    predicate: PredicateDeclaration;
    structure: StructureDeclaration;
}
export declare const nodeImplementationsByKind: Record<NodeKind, UnknownNodeImplementation>;
export declare const nodeClassesByKind: Record<NodeKind, new (attachments: UnknownAttachments, $: RawRootScope) => BaseNode>;
interface NodesByKind extends BoundNodesByKind {
    alias: AliasNode;
    union: UnionNode;
    morph: MorphNode;
    intersection: IntersectionNode;
    unit: UnitNode;
    proto: ProtoNode;
    domain: DomainNode;
    divisor: DivisorNode;
    pattern: PatternNode;
    predicate: PredicateNode;
    required: RequiredNode;
    optional: OptionalNode;
    index: IndexNode;
    sequence: SequenceNode;
    structure: StructureNode;
}
export type Node<kind extends NodeKind> = NodesByKind[kind];
export type Declaration<kind extends NodeKind> = NodeDeclarationsByKind[kind];
export type NodeSchema<kind extends NodeKind> = Declaration<kind>["schema"];
export type RootSchema<kind extends RootKind = RootKind> = NodeSchema<kind>;
export type NormalizedSchema<kind extends NodeKind> = Declaration<kind>["normalizedSchema"];
export type childKindOf<kind extends NodeKind> = Declaration<kind>["childKind"];
export type Prerequisite<kind extends NodeKind> = Declaration<kind>["prerequisite"];
export type reducibleKindOf<kind extends NodeKind> = Declaration<kind>["reducibleTo"] extends NodeKind ? Declaration<kind>["reducibleTo"] : kind;
export type Inner<kind extends NodeKind> = Declaration<kind>["inner"];
export type defAttachedAs<kind extends ConstraintKind> = kind extends OpenNodeKind ? listable<NodeSchema<kind>> : NodeSchema<kind>;
export type innerAttachedAs<kind extends ConstraintKind> = kind extends OpenNodeKind ? array<Node<kind>> : Node<kind>;
/** make nested arrays mutable while keeping nested nodes immutable */
export type MutableInner<kind extends NodeKind> = makeRootAndArrayPropertiesMutable<Inner<kind>>;
export type MutableNormalizedRoot<kind extends NodeKind> = makeRootAndArrayPropertiesMutable<NormalizedSchema<kind>>;
export type errorContext<kind extends NodeKind> = Declaration<kind>["errorContext"];
export {};
