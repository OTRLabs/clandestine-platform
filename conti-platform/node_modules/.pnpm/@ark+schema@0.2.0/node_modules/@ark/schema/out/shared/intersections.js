import { Hkt } from "@ark/util";
import { Disjoint } from "./disjoint.js";
import { isNode } from "./utils.js";
const intersectionCache = {};
export const intersectNodesRoot = (l, r, $) => intersectNodes(l, r, {
    $,
    invert: false,
    pipe: false
});
export const pipeNodesRoot = (l, r, $) => intersectNodes(l, r, {
    $,
    invert: false,
    pipe: true
});
export const intersectNodes = (l, r, ctx) => {
    const operator = ctx.pipe ? "|>" : "&";
    const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;
    if (intersectionCache[lrCacheKey] !== undefined)
        return intersectionCache[lrCacheKey];
    if (!ctx.pipe) {
        // we can only use this for the commutative & operator
        const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;
        if (intersectionCache[rlCacheKey] !== undefined) {
            // if the cached result was a Disjoint and the operands originally
            // appeared in the opposite order, we need to invert it to match
            const rlResult = intersectionCache[rlCacheKey];
            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;
            // add the lr result to the cache directly to bypass this check in the future
            intersectionCache[lrCacheKey] = lrResult;
            return lrResult;
        }
    }
    if (l.equals(r))
        return l;
    let result;
    if (ctx.pipe && l.kind !== "union" && r.kind !== "union") {
        if (l.includesMorph) {
            if (l.hasKind("morph")) {
                result =
                    ctx.invert ?
                        pipeToMorph(r, l, ctx)
                        : pipeFromMorph(l, r, ctx);
            }
            else {
                result = ctx.$.node("morph", {
                    morphs: [r],
                    in: l
                });
            }
        }
        else if (r.includesMorph) {
            if (!r.hasKind("morph")) {
                result = ctx.$.node("morph", {
                    morphs: [r],
                    in: l
                });
            }
            else {
                result =
                    ctx.invert ?
                        pipeFromMorph(r, l, ctx)
                        : pipeToMorph(l, r, ctx);
            }
        }
    }
    if (!result) {
        const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;
        const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];
        if (implementation === undefined) {
            // should be two ConstraintNodes that have no relation
            // this could also happen if a user directly intersects a Type and a ConstraintNode,
            // but that is not allowed by the external function signature
            result = null;
        }
        else if (leftmostKind === l.kind)
            result = implementation(l, r, ctx);
        else {
            result = implementation(r, l, { ...ctx, invert: !ctx.invert });
            if (result instanceof Disjoint)
                result = result.invert();
        }
    }
    if (isNode(result)) {
        // if the result equals one of the operands, preserve its metadata by
        // returning the original reference
        if (l.equals(result))
            result = l;
        else if (r.equals(result))
            result = r;
    }
    intersectionCache[lrCacheKey] = result;
    return result;
};
export const pipeFromMorph = (from, to, ctx) => {
    const morphs = [...from.morphs];
    if (from.validatedOut) {
        // still piped from context, so allows appending additional morphs
        const outIntersection = intersectNodes(from.validatedOut, to, ctx);
        if (outIntersection instanceof Disjoint)
            return outIntersection;
        morphs[morphs.length - 1] = outIntersection;
    }
    else
        morphs.push(to);
    return ctx.$.node("morph", {
        morphs,
        in: from.in
    });
};
export const pipeToMorph = (from, to, ctx) => {
    const result = intersectNodes(from, to.in, ctx);
    if (result instanceof Disjoint)
        return result;
    return ctx.$.node("morph", {
        morphs: to.morphs,
        in: result
    });
};
