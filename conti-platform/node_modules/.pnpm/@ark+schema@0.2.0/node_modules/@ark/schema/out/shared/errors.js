import { CastableBase, ReadonlyArray, defineProperties } from "@ark/util";
import { arkKind, pathToPropString } from "./utils.js";
export class ArkError extends CastableBase {
    input;
    [arkKind] = "error";
    path;
    data;
    nodeConfig;
    constructor(input, ctx) {
        super();
        this.input = input;
        defineProperties(this, input);
        const data = ctx.data;
        if (input.code === "union") {
            // flatten union errors to avoid repeating context like "foo must be foo must be"...
            input.errors = input.errors.flatMap(e => e.hasCode("union") ? e.errors : e);
        }
        this.nodeConfig = ctx.config[this.code];
        this.path = input.path ?? [...ctx.path];
        if (input.relativePath)
            this.path.push(...input.relativePath);
        this.data = "data" in input ? input.data : data;
    }
    hasCode(code) {
        return this.code === code;
    }
    get propString() {
        return pathToPropString(this.path);
    }
    get expected() {
        return (this.input.expected ?? this.nodeConfig.expected?.(this.input));
    }
    get actual() {
        // null is a valid value of actual meaning it should be omitted, so
        // check for undefined explicitly
        return this.input.actual !== undefined ?
            this.input.actual
            : this.nodeConfig.actual?.(this.data);
    }
    get problem() {
        return this.input.problem ?? this.nodeConfig.problem(this);
    }
    get message() {
        return this.input.message ?? this.nodeConfig.message(this);
    }
    toString() {
        return this.message;
    }
    throw() {
        throw this;
    }
}
export class ArkErrors extends ReadonlyArray {
    ctx;
    constructor(ctx) {
        super();
        this.ctx = ctx;
    }
    byPath = {};
    count = 0;
    mutable = this;
    add(error) {
        const existing = this.byPath[error.propString];
        if (existing) {
            const errorIntersection = new ArkError({
                code: "intersection",
                errors: existing.hasCode("intersection") ?
                    [...existing.errors, error]
                    : [existing, error]
            }, this.ctx);
            const existingIndex = this.indexOf(existing);
            // If existing is found (which it always should be unless this was externally mutated),
            // replace it with the new problem intersection. In case it isn't for whatever reason,
            // just append the intersection.
            this.mutable[existingIndex === -1 ? this.length : existingIndex] =
                errorIntersection;
            this.byPath[error.propString] = errorIntersection;
        }
        else {
            this.byPath[error.propString] = error;
            this.mutable.push(error);
        }
        this.count++;
    }
    get summary() {
        return this.toString();
    }
    get message() {
        return this.toString();
    }
    toString() {
        return this.join("\n");
    }
    throw() {
        throw new AggregateError(this, this.message);
    }
}
