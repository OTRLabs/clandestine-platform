import { CompiledFunction } from "@ark/util";
export class NodeCompiler extends CompiledFunction {
    traversalKind;
    path = [];
    discriminants = [];
    constructor(traversalKind) {
        super("data", "ctx");
        this.traversalKind = traversalKind;
    }
    invoke(node, opts) {
        const arg = opts?.arg ?? this.data;
        if (this.requiresContextFor(node))
            return `${this.reference(node, opts)}(${arg}, ${this.ctx})`;
        return `${this.reference(node, opts)}(${arg})`;
    }
    reference(node, opts) {
        const invokedKind = opts?.kind ?? this.traversalKind;
        const base = `this.${node.id}${invokedKind}`;
        return opts?.bind ? `${base}.bind(${opts?.bind})` : base;
    }
    requiresContextFor(node) {
        return this.traversalKind === "Apply" || node.allowsRequiresContext;
    }
    initializeErrorCount() {
        return this.const("errorCount", "ctx.currentErrorCount");
    }
    returnIfFail() {
        return this.if("ctx.currentErrorCount > errorCount", () => this.return());
    }
    returnIfFailFast() {
        return this.if("ctx.failFast && ctx.currentErrorCount > errorCount", () => this.return());
    }
    traverseKey(keyExpression, accessExpression, node) {
        const requiresContext = this.requiresContextFor(node);
        if (requiresContext)
            this.line(`${this.ctx}.path.push(${keyExpression})`);
        this.check(node, {
            arg: accessExpression
        });
        if (requiresContext)
            this.line(`${this.ctx}.path.pop()`);
        return this;
    }
    check(node, opts) {
        return this.traversalKind === "Allows" ?
            this.if(`!${this.invoke(node, opts)}`, () => this.return(false))
            : this.line(this.invoke(node, opts));
    }
    writeMethod(name) {
        return `${name}(${this.argNames.join(", ")}){\n${this.body}    }\n`;
    }
}
