import { domainDescriptions, domainOf, printable, prototypeKeysOf } from "@ark/util";
import { Disjoint } from "../shared/disjoint.js";
import { defaultValueSerializer, implementNode } from "../shared/implement.js";
import { RawBasis } from "./basis.js";
import { defineRightwardIntersections } from "./utils.js";
export const unitImplementation = implementNode({
    kind: "unit",
    hasAssociatedError: true,
    keys: {
        unit: {
            preserveUndefined: true,
            serialize: schema => schema instanceof Date ?
                schema.toISOString()
                : defaultValueSerializer(schema)
        }
    },
    normalize: schema => schema,
    defaults: {
        description: node => printable(node.unit),
        problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`
    },
    intersections: {
        unit: (l, r) => Disjoint.init("unit", l, r),
        ...defineRightwardIntersections("unit", (l, r) => r.allows(l.unit) ? l : (Disjoint.init("assignability", l, r.hasKind("intersection") ?
            r.children.find(rConstraint => !rConstraint.allows(l.unit))
            : r)))
    }
});
export class UnitNode extends RawBasis {
    compiledValue = this.json.unit;
    serializedValue = typeof this.unit === "string" || this.unit instanceof Date ?
        JSON.stringify(this.compiledValue)
        : this.compiledValue;
    literalKeys = prototypeKeysOf(this.unit);
    compiledCondition = compileEqualityCheck(this.unit, this.serializedValue);
    compiledNegation = compileEqualityCheck(this.unit, this.serializedValue, "negated");
    expression = printable(this.unit);
    domain = domainOf(this.unit);
    get shortDescription() {
        return this.domain === "object" ?
            domainDescriptions.object
            : this.description;
    }
    traverseAllows = this.unit instanceof Date ?
        data => data instanceof Date && data.toISOString() === this.compiledValue
        : data => data === this.unit;
}
const compileEqualityCheck = (unit, serializedValue, negated) => {
    if (unit instanceof Date) {
        const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;
        return negated ? `!(${condition})` : condition;
    }
    return `data ${negated ? "!" : "="}== ${serializedValue}`;
};
