import { Callable, type array, type thunkable } from "@ark/util";
import type { inferRoot } from "./inference.js";
import type { RootSchema } from "./kinds.js";
import type { Root, UnknownRoot } from "./roots/root.js";
import type { RawRootScope, RootScope } from "./scope.js";
import { arkKind } from "./shared/utils.js";
export type GenericParamAst<name extends string = string, constraint = unknown> = readonly [name: name, constraint: constraint];
export type GenericParamDef<name extends string = string> = name | ConstrainedGenericParamDef;
export type ConstrainedGenericParamDef<name extends string = string> = GenericParamAst<name>;
export declare const parseGeneric: (paramDefs: array<GenericParamDef>, bodyDef: unknown, $: thunkable<RootScope>) => GenericRoot;
type genericParamSchemaToAst<schema extends GenericParamDef, $> = schema extends string ? GenericParamAst<schema> : schema extends ConstrainedGenericParamDef ? GenericParamAst<schema[0], inferRoot<schema[1], $>> : never;
export type genericParamSchemasToAst<schemas extends array<GenericParamDef>, $> = readonly [
    ...{
        [i in keyof schemas]: genericParamSchemaToAst<schemas[i], $>;
    }
];
export type genericParamAstToDefs<asts extends array<GenericParamAst>> = {
    [i in keyof asts]: GenericParamDef<asts[i][0]>;
};
export type genericParamNames<params extends array<GenericParamAst>> = {
    [i in keyof params]: params[i][0];
};
export type genericParamConstraints<params extends array<GenericParamAst>> = {
    [i in keyof params]: params[i][1];
};
type instantiateParams<params extends array<GenericParamAst>> = {
    [i in keyof params]: params[i] extends (GenericParamAst<infer name, infer constraint>) ? GenericParam<name, constraint> : never;
};
export type GenericNodeSignature<params extends array<GenericParamAst>, def, $> = <args extends instantiateConstraintsOf<params>>(...args: args) => Root<inferRoot<def, $ & bindGenericNodeInstantiation<params, $, args>>>;
type instantiateConstraintsOf<params extends array<GenericParamAst>> = {
    [i in keyof params]: Root<params[i][1]>;
};
export type GenericParam<name extends string = string, constraint = unknown> = readonly [name: name, constraint: UnknownRoot<constraint>];
export type bindGenericNodeInstantiation<params extends array<GenericParamAst>, $, args> = {
    [i in keyof params & `${number}` as params[i][0]]: inferRoot<args[i & keyof args], $>;
};
export interface GenericProps<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = any, $ = any> {
    [arkKind]: "generic";
    params: instantiateParams<params>;
    names: genericParamNames<params>;
    constraints: instantiateConstraintsOf<params>;
    bodyDef: bodyDef;
    $: RootScope<$>;
}
export type GenericArgResolutions<params extends array<GenericParamAst> = array<GenericParamAst>> = {
    [i in keyof params as params[i & `${number}`][0]]: UnknownRoot<params[i & `${number}`][1]>;
};
export type LazyGenericSchema<params extends array<GenericParamAst> = array<GenericParamAst>, returns extends RootSchema = RootSchema> = (args: GenericArgResolutions<params>) => returns;
export declare class LazyGenericRoot<params extends array<GenericParamAst> = array<GenericParamAst>> extends Callable<LazyGenericSchema<params>> {
}
export declare class GenericRoot<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = any, $ = any> extends Callable<GenericNodeSignature<params, bodyDef, $>> implements GenericProps {
    paramDefs: genericParamAstToDefs<params>;
    bodyDef: bodyDef;
    private _$;
    private _arg$;
    readonly [arkKind] = "generic";
    constructor(paramDefs: genericParamAstToDefs<params>, bodyDef: bodyDef, _$: thunkable<RootScope<$>>, _arg$: thunkable<RootScope<$>>);
    get $(): RootScope<$>;
    get arg$(): RootScope<$>;
    bindScope($: RawRootScope): this;
    get params(): instantiateParams<params>;
    get names(): genericParamNames<params>;
    get constraints(): instantiateConstraintsOf<params>;
    get baseInstantiation(): Root;
    validateBaseInstantiation(): this;
    get internal(): this;
    get references(): import("./node.js").BaseNode<import("./index.js").RawNodeDeclaration>[];
}
export declare const writeUnsatisfiedParameterConstraintMessage: <name extends string, constraint extends string, arg extends string>(name: name, constraint: constraint, arg: arg) => writeUnsatisfiedParameterConstraintMessage<name, constraint, arg>;
export type writeUnsatisfiedParameterConstraintMessage<name extends string, constraint extends string, arg extends string> = `${name} must be assignable to ${constraint} (was ${arg})`;
export {};
