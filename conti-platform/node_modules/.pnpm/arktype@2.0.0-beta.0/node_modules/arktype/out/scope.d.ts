import { RawRootScope, type AliasDefEntry, type ArkConfig, type BaseRoot, type GenericArgResolutions, type GenericParamAst, type GenericParamDef, type GenericProps, type PreparsedNodeResolution, type PrivateDeclaration, type RawRootResolutions, type RootScope, type arkKind, type destructuredExportContext, type destructuredImportContext, type exportedNameOf, type writeDuplicateAliasError } from "@ark/schema";
import { type anyOrNever, type array, type keyError, type nominal, type show } from "@ark/util";
import { parseGenericParams, type Generic, type GenericDeclaration, type ParameterString, type baseGenericArgs, type parseValidGenericParams } from "./generic.js";
import { type MatchParser } from "./match.js";
import type { Module } from "./module.js";
import { type inferDefinition, type validateDefinition } from "./parser/definition.js";
import type { ParsedDefault } from "./parser/string/shift/operator/default.js";
import { RawTypeParser, type DeclarationParser, type DefinitionParser, type Type, type TypeParser } from "./type.js";
export type ScopeParser = <const def>(def: validateScope<def>, config?: ArkConfig) => Scope<inferScope<def>>;
export type validateScope<def> = {
    [k in keyof def]: k extends symbol ? unknown : parseScopeKey<k, def>["params"] extends infer params ? params extends array<GenericParamAst> ? params["length"] extends 0 ? def[k] extends Type | PreparsedResolution ? def[k] : k extends PrivateDeclaration<infer name extends keyof def & string> ? keyError<writeDuplicateAliasError<name>> : validateDefinition<def[k], bootstrapAliases<def>, {}> : validateDefinition<def[k], bootstrapAliases<def>, baseGenericArgs<params>> : params : never;
};
export type inferScope<def> = inferBootstrapped<bootstrapAliases<def>>;
export type bindThis<def> = {
    this: Def<def>;
};
/** nominal type for an unparsed definition used during scope bootstrapping */
type Def<def = {}> = nominal<def, "unparsed">;
/** sentinel indicating a scope that will be associated with a generic has not yet been parsed */
export type UnparsedScope = "$";
/** These are legal as values of a scope but not as definitions in other contexts */
type PreparsedResolution = PreparsedNodeResolution;
type bootstrapAliases<def> = {
    [k in Exclude<keyof def, GenericDeclaration | symbol>]: def[k] extends PreparsedResolution ? def[k] : def[k] extends (() => infer thunkReturn extends PreparsedResolution) ? thunkReturn : Def<def[k]>;
} & {
    [k in keyof def & GenericDeclaration as extractGenericName<k>]: GenericProps<parseValidGenericParams<extractGenericParameters<k>, bootstrapAliases<def>>, def[k], UnparsedScope>;
};
type inferBootstrapped<$> = show<{
    [name in keyof $]: $[name] extends Def<infer def> ? inferDefinition<def, $, {}> : $[name] extends (Generic<infer params, infer def> | GenericProps<infer params, infer def>) ? Generic<params, def, $> : $[name];
}>;
type extractGenericName<k> = k extends GenericDeclaration<infer name> ? name : never;
type extractGenericParameters<k> = k extends `${string}<${infer params}>` ? ParameterString<params> : never;
export type resolve<reference extends keyof $ | keyof args, $, args> = (reference extends keyof args ? args[reference] : $[reference & keyof $]) extends infer resolution ? [
    resolution
] extends [anyOrNever] ? resolution : resolution extends Def<infer def> ? inferDefinition<def, $, args> : resolution : never;
export type moduleKeyOf<$> = {
    [k in keyof $]: $[k] extends {
        [arkKind]: "module";
    } ? k & string : never;
}[keyof $];
export type tryInferSubmoduleReference<$, token> = token extends `${infer submodule extends moduleKeyOf<$>}.${infer subalias}` ? subalias extends keyof $[submodule] ? $[submodule][subalias] : never : token extends `${infer submodule}.${infer subalias}` ? submodule extends moduleKeyOf<ArkEnv.$> ? subalias extends keyof ArkEnv.$[submodule] ? ArkEnv.$[submodule][subalias] : never : never : never;
export interface ParseContext extends TypeParseOptions {
    $: RawScope;
}
export interface TypeParseOptions {
    args?: GenericArgResolutions;
}
export declare const scope: ScopeParser;
export interface Scope<$ = any> extends RootScope<$> {
    type: TypeParser<$>;
    match: MatchParser<$>;
    declare: DeclarationParser<$>;
    define: DefinitionParser<$>;
    import<names extends exportedNameOf<$>[]>(...names: names): Module<show<destructuredImportContext<$, names>>>;
    export<names extends exportedNameOf<$>[]>(...names: names): Module<show<destructuredExportContext<$, names>>>;
}
export declare class RawScope<$ extends RawRootResolutions = RawRootResolutions> extends RawRootScope<$> {
    private parseCache;
    constructor(def: Record<string, unknown>, config?: ArkConfig);
    type: RawTypeParser;
    match: MatchParser<$>;
    declare: () => {
        type: RawTypeParser;
    };
    define: (def: unknown) => unknown;
    preparseAlias(k: string, v: unknown): AliasDefEntry;
    preparseRoot(def: unknown): unknown;
    parseRoot(def: unknown, opts?: TypeParseOptions): BaseRoot;
    parse<defaultable extends boolean = false>(def: unknown, ctx: ParseContext, defaultable?: defaultable): BaseRoot | (defaultable extends false ? never : ParsedDefault);
    parseString<defaultable extends boolean>(def: string, ctx: ParseContext, defaultable: defaultable): BaseRoot | (defaultable extends false ? never : ParsedDefault);
}
export declare const writeShallowCycleErrorMessage: (name: string, seen: string[]) => string;
export type ParsedScopeKey = {
    name: string;
    params: array<GenericParamDef>;
};
export type parseScopeKey<k, def> = k extends `${infer name}<${infer params}>` ? {
    name: name;
    params: parseGenericParams<params, bootstrapAliases<def>>;
} : {
    name: k;
    params: [];
};
export {};
