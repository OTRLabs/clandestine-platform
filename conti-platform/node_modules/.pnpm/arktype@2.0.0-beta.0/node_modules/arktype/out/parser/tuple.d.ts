import { type BaseMeta, type BaseRoot, type Morph, type Out, type Predicate, type distillConstrainableIn, type distillOut, type inferIntersection, type inferMorphOut, type inferPredicate } from "@ark/schema";
import { type BuiltinObjectKind, type Constructor, type Domain, type ErrorMessage, type array, type conform, type show } from "@ark/util";
import type { ParseContext } from "../scope.js";
import type { inferDefinition, validateDefinition } from "./definition.js";
import type { InfixOperator, PostfixExpression } from "./semantic/infer.js";
import { writeMissingRightOperandMessage } from "./string/shift/operand/unenclosed.js";
import type { BaseCompletions } from "./string/string.js";
export declare const parseTuple: (def: array, ctx: ParseContext) => BaseRoot;
export declare const parseTupleLiteral: (def: array, ctx: ParseContext) => BaseRoot;
type InfixExpression = readonly [unknown, InfixOperator, ...unknown[]];
export type validateTuple<def extends array, $, args> = def extends IndexZeroExpression ? validatePrefixExpression<def, $, args> : def extends PostfixExpression ? validatePostfixExpression<def, $, args> : def extends InfixExpression ? validateInfixExpression<def, $, args> : def extends (readonly ["", ...unknown[]] | readonly [unknown, "", ...unknown[]]) ? readonly [
    def[0] extends "" ? BaseCompletions<$, args, IndexZeroOperator | "..."> : def[0],
    def[1] extends "" ? BaseCompletions<$, args, IndexOneOperator | "..." | "?"> : def[1]
] : validateTupleLiteral<def, $, args>;
export type validateTupleLiteral<def extends array, $, args> = parseSequence<def, $, args> extends infer s extends SequenceParseState ? Readonly<s["validated"]> : never;
type inferTupleLiteral<def extends array, $, args> = parseSequence<def, $, args> extends infer s extends SequenceParseState ? s["inferred"] : never;
type SequenceParseState = {
    unscanned: array;
    inferred: array;
    validated: array;
};
type parseSequence<def extends array, $, args> = parseNextElement<{
    unscanned: def;
    inferred: [];
    validated: [];
}, $, args>;
type PreparsedElement = {
    head: unknown;
    tail: array;
    optional: boolean;
    spread: boolean;
};
declare namespace PreparsedElement {
    type from<result extends PreparsedElement> = result;
}
type preparseNextElement<s extends SequenceParseState> = s["unscanned"] extends readonly ["...", infer head, ...infer tail] ? tail extends readonly ["?", ...infer postOptionalTail] ? PreparsedElement.from<{
    head: head;
    tail: postOptionalTail;
    optional: true;
    spread: true;
}> : PreparsedElement.from<{
    head: head;
    tail: tail;
    optional: false;
    spread: true;
}> : s["unscanned"] extends readonly [infer head, "?", ...infer tail] ? PreparsedElement.from<{
    head: head;
    tail: tail;
    optional: true;
    spread: false;
}> : s["unscanned"] extends readonly [infer head, ...infer tail] ? PreparsedElement.from<{
    head: head;
    tail: tail;
    optional: false;
    spread: false;
}> : null;
type parseNextElement<s extends SequenceParseState, $, args> = preparseNextElement<s> extends infer next extends PreparsedElement ? parseNextElement<{
    unscanned: next["tail"];
    inferred: next["spread"] extends true ? [
        ...s["inferred"],
        ...conform<inferDefinition<next["head"], $, args>, array>
    ] : next["optional"] extends true ? [
        ...s["inferred"],
        inferDefinition<next["head"], $, args>?
    ] : [...s["inferred"], inferDefinition<next["head"], $, args>];
    validated: [
        ...s["validated"],
        ...(next["spread"] extends true ? [
            inferDefinition<next["head"], $, args> extends (infer spreadOperand extends array) ? [
                number,
                number
            ] extends ([
                s["inferred"]["length"],
                spreadOperand["length"]
            ]) ? ErrorMessage<multipleVariadicMessage> : "..." : ErrorMessage<writeNonArraySpreadMessage<next["head"]>>
        ] : []),
        [
            next["optional"] | next["spread"],
            "?"
        ] extends ([
            false,
            s["validated"][number]
        ]) ? ErrorMessage<requiredPostOptionalMessage> : validateDefinition<next["head"], $, args>,
        ...(next["optional"] extends true ? [
            next["spread"] extends true ? ErrorMessage<spreadOptionalMessage> : number extends s["inferred"]["length"] ? ErrorMessage<optionalPostVariadicMessage> : "?"
        ] : [])
    ];
}, $, args> : s;
export declare const writeNonArraySpreadMessage: <operand extends string>(operand: operand) => writeNonArraySpreadMessage<operand>;
type writeNonArraySpreadMessage<operand> = `Spread element must be an array${operand extends string ? ` (was ${operand})` : ""}`;
export declare const multipleVariadicMesage = "A tuple may have at most one variadic element";
type multipleVariadicMessage = typeof multipleVariadicMesage;
export declare const requiredPostOptionalMessage = "A required element may not follow an optional element";
type requiredPostOptionalMessage = typeof requiredPostOptionalMessage;
export declare const optionalPostVariadicMessage = "An optional element may not follow a variadic element";
type optionalPostVariadicMessage = typeof optionalPostVariadicMessage;
export declare const spreadOptionalMessage = "A spread element cannot be optional";
type spreadOptionalMessage = typeof optionalPostVariadicMessage;
export type inferTuple<def extends array, $, args> = def extends TupleExpression ? inferTupleExpression<def, $, args> : inferTupleLiteral<def, $, args>;
export type inferTupleExpression<def extends TupleExpression, $, args> = def[1] extends "[]" ? inferDefinition<def[0], $, args>[] : def[1] extends "&" ? inferIntersection<inferDefinition<def[0], $, args>, inferDefinition<def[2], $, args>> : def[1] extends "|" ? inferDefinition<def[0], $, args> | inferDefinition<def[2], $, args> : def[1] extends ":" ? inferPredicate<inferDefinition<def[0], $, args>, def[2]> : def[1] extends "=>" ? parseMorph<def[0], def[2], $, args> : def[1] extends "@" ? inferDefinition<def[0], $, args> : def extends readonly ["===", ...infer values] ? values[number] : def extends (readonly ["instanceof", ...infer constructors extends Constructor[]]) ? InstanceType<constructors[number]> : def[0] extends "keyof" ? inferKeyOfExpression<def[1], $, args> : never;
export type validatePrefixExpression<def extends IndexZeroExpression, $, args> = def["length"] extends 1 ? readonly [writeMissingRightOperandMessage<def[0]>] : def[0] extends "keyof" ? readonly [def[0], validateDefinition<def[1], $, args>] : def[0] extends "===" ? readonly [def[0], ...unknown[]] : def[0] extends "instanceof" ? readonly [def[0], ...Constructor[]] : never;
export type validatePostfixExpression<def extends PostfixExpression, $, args> = conform<def, readonly [validateDefinition<def[0], $, args>, "[]"]>;
export type validateInfixExpression<def extends InfixExpression, $, args> = def["length"] extends 2 ? readonly [def[0], writeMissingRightOperandMessage<def[1]>] : readonly [
    validateDefinition<def[0], $, args>,
    def[1],
    def[1] extends "|" ? validateDefinition<def[2], $, args> : def[1] extends "&" ? validateDefinition<def[2], $, args> : def[1] extends ":" ? Predicate<distillOut<inferDefinition<def[0], $, args>>> : def[1] extends "=>" ? Morph<distillOut<inferDefinition<def[0], $, args>>, unknown> : def[1] extends "@" ? BaseMeta | string : validateDefinition<def[2], $, args>
];
export type UnparsedTupleExpressionInput = {
    instanceof: Constructor;
    "===": unknown;
};
export type UnparsedTupleOperator = show<keyof UnparsedTupleExpressionInput>;
export declare const parseKeyOfTuple: PrefixParser<"keyof">;
export type inferKeyOfExpression<operandDef, $, args> = show<keyof inferDefinition<operandDef, $, args>>;
export type PostfixParser<token extends IndexOneOperator> = (def: IndexOneExpression<token>, ctx: ParseContext) => BaseRoot;
export type PrefixParser<token extends IndexZeroOperator> = (def: IndexZeroExpression<token>, ctx: ParseContext) => BaseRoot;
export type TupleExpression = IndexZeroExpression | IndexOneExpression;
export type TupleExpressionOperator = IndexZeroOperator | IndexOneOperator;
export type IndexOneOperator = TuplePostfixOperator | TupleInfixOperator;
export type TuplePostfixOperator = "[]";
export type TupleInfixOperator = "&" | "|" | "=>" | ":" | "@";
export type IndexOneExpression<token extends IndexOneOperator = IndexOneOperator> = readonly [unknown, token, ...unknown[]];
export declare const parseMorphTuple: PostfixParser<"=>">;
export declare const writeMalformedFunctionalExpressionMessage: (operator: ":" | "=>", value: unknown) => string;
export type parseMorph<inDef, morph, $, args> = morph extends Morph ? inferMorphOut<morph> extends infer out ? (In: distillConstrainableIn<inferDefinition<inDef, $, args>>) => Out<out> : never : never;
export declare const parseNarrowTuple: PostfixParser<":">;
export type IndexZeroOperator = "keyof" | "instanceof" | "===";
export type IndexZeroExpression<token extends IndexZeroOperator = IndexZeroOperator> = readonly [token, ...unknown[]];
export declare const writeInvalidConstructorMessage: <actual extends Domain | BuiltinObjectKind>(actual: actual) => string;
export {};
