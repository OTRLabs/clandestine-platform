import { type BaseRoot, type BoundKind, type LimitLiteral } from "@ark/schema";
import { type keySet } from "@ark/util";
import type { astToString } from "../../../semantic/utils.js";
import type { DynamicState, DynamicStateWithRoot } from "../../reduce/dynamic.js";
import { writeUnpairableComparatorMessage, type Comparator, type InvertedComparators, type MaxComparator } from "../../reduce/shared.js";
import type { StaticState, state } from "../../reduce/static.js";
import type { parseOperand } from "../operand/operand.js";
import type { Scanner } from "../scanner.js";
export declare const parseBound: (s: DynamicStateWithRoot, start: ComparatorStartChar) => void;
export type parseBound<s extends StaticState, start extends ComparatorStartChar, unscanned extends string, $, args> = shiftComparator<start, unscanned> extends infer shiftResultOrError ? shiftResultOrError extends (Scanner.shiftResult<infer comparator extends Comparator, infer nextUnscanned>) ? s["root"] extends `${infer limit extends LimitLiteral}` ? state.reduceLeftBound<s, limit, comparator, nextUnscanned> : parseRightBound<state.scanTo<s, nextUnscanned>, comparator, $, args> : shiftResultOrError : never;
declare const oneCharComparators: {
    readonly "<": true;
    readonly ">": true;
};
type OneCharComparator = keyof typeof oneCharComparators;
export type ComparatorStartChar = Comparator extends `${infer char}${string}` ? char : never;
export declare const comparatorStartChars: keySet<ComparatorStartChar>;
declare const shiftComparator: (s: DynamicState, start: ComparatorStartChar) => Comparator;
type shiftComparator<start extends ComparatorStartChar, unscanned extends string> = unscanned extends `=${infer nextUnscanned}` ? [`${start}=`, nextUnscanned] : [start & OneCharComparator, unscanned];
export declare const writeIncompatibleRangeMessage: (l: BoundKind, r: BoundKind) => string;
export declare const getBoundKinds: (comparator: Comparator, limit: LimitLiteral, root: BaseRoot, boundKind: BoundExpressionKind) => BoundKind[];
export declare const parseRightBound: (s: DynamicStateWithRoot, comparator: Comparator) => void;
export type parseRightBound<s extends StaticState, comparator extends Comparator, $, args> = parseOperand<s, $, args> extends infer nextState extends StaticState ? nextState["root"] extends `${infer limit extends LimitLiteral}` ? s["branches"]["leftBound"] extends {} ? comparator extends MaxComparator ? state.reduceRange<s, s["branches"]["leftBound"]["limit"], s["branches"]["leftBound"]["comparator"], comparator, limit, nextState["unscanned"]> : state.error<writeUnpairableComparatorMessage<comparator>> : state.reduceSingleBound<s, comparator, limit, nextState["unscanned"]> : state.error<writeInvalidLimitMessage<comparator, astToString<nextState["root"]>, "right">> : never;
export declare const writeInvalidLimitMessage: <comparator extends Comparator, limit extends string | number, boundKind extends BoundExpressionKind>(comparator: comparator, limit: limit, boundKind: boundKind) => writeInvalidLimitMessage<comparator, limit, boundKind>;
export type writeInvalidLimitMessage<comparator extends Comparator, limit extends string | number, boundKind extends BoundExpressionKind> = `Comparator ${boundKind extends "left" ? InvertedComparators[comparator] : comparator} must be ${boundKind extends "left" ? "preceded" : "followed"} by a corresponding literal (was ${limit})`;
export type BoundExpressionKind = "left" | "right";
export {};
