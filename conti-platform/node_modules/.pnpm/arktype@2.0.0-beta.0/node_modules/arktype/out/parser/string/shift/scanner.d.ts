import { type Dict, type EscapeToken, type WhiteSpaceToken } from "@ark/util";
import type { Comparator } from "../reduce/shared.js";
export declare class Scanner<lookahead extends string = string> {
    private chars;
    private i;
    constructor(def: string);
    /** Get lookahead and advance scanner by one */
    shift(): lookahead;
    get lookahead(): lookahead;
    get nextLookahead(): string;
    get length(): number;
    shiftUntil(condition: Scanner.UntilCondition): string;
    shiftUntilNextTerminator(): string;
    shiftUntilNonWhitespace(): string;
    jumpToIndex(i: number): void;
    jumpForward(count: number): void;
    get location(): number;
    get unscanned(): string;
    get scanned(): string;
    sliceChars(start: number, end?: number): string;
    lookaheadIs<char extends lookahead>(char: char): this is Scanner<char>;
    lookaheadIsIn<tokens extends Dict>(tokens: tokens): this is Scanner<Extract<keyof tokens, string>>;
}
export declare namespace Scanner {
    type UntilCondition = (scanner: Scanner, shifted: string) => boolean;
    type OnInputEndFn = (scanner: Scanner, shifted: string) => string;
    type ShiftUntilOptions = {
        onInputEnd?: OnInputEndFn;
    };
    const lookaheadIsTerminator: UntilCondition;
    const lookaheadIsNotWhitespace: UntilCondition;
    const terminatingChars: {
        readonly "<": true;
        readonly ">": true;
        readonly "=": true;
        readonly "|": true;
        readonly "&": true;
        readonly ")": true;
        readonly "[": true;
        readonly "%": true;
        readonly " ": true;
        readonly ",": true;
        readonly ":": true;
    };
    type TerminatingChar = keyof typeof terminatingChars;
    const finalizingLookaheads: {
        readonly ">": true;
        readonly ",": true;
        readonly "": true;
        readonly "=": true;
    };
    type FinalizingLookahead = keyof typeof finalizingLookaheads;
    type InfixToken = Comparator | "|" | "&" | "%" | ":" | "=>";
    type PostfixToken = "[]";
    type OperatorToken = InfixToken | PostfixToken;
    const lookaheadIsFinalizing: (lookahead: string, unscanned: string) => lookahead is ">" | "," | "=";
    type lookaheadIsFinalizing<lookahead extends string, unscanned extends string> = lookahead extends ">" ? unscanned extends `=${infer nextUnscanned}` ? nextUnscanned extends `=${string}` ? true : false : Scanner.skipWhitespace<unscanned> extends ("" | `${TerminatingChar}${string}`) ? true : false : lookahead extends "=" ? unscanned extends `=${string}` ? false : true : lookahead extends "," ? true : false;
    type shift<lookahead extends string, unscanned extends string> = `${lookahead}${unscanned}`;
    type shiftUntil<unscanned extends string, terminator extends string, scanned extends string = ""> = unscanned extends shift<infer lookahead, infer nextUnscanned> ? lookahead extends terminator ? scanned extends `${infer base}${EscapeToken}` ? shiftUntil<nextUnscanned, terminator, `${base}${lookahead}`> : [scanned, unscanned] : shiftUntil<nextUnscanned, terminator, `${scanned}${lookahead}`> : [scanned, ""];
    type shiftUntilNot<unscanned extends string, nonTerminator extends string, scanned extends string = ""> = unscanned extends shift<infer lookahead, infer nextUnscanned> ? lookahead extends nonTerminator ? shiftUntilNot<nextUnscanned, nonTerminator, `${scanned}${lookahead}`> : [scanned, unscanned] : [scanned, ""];
    type shiftUntilNextTerminator<unscanned extends string> = shiftUntil<unscanned, TerminatingChar>;
    type skipWhitespace<unscanned extends string> = shiftUntilNot<unscanned, WhiteSpaceToken>[1];
    type shiftResult<scanned extends string, unscanned extends string> = [
        scanned,
        unscanned
    ];
}
