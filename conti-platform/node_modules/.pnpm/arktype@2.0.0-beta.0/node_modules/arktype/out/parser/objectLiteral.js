import { ArkErrors, normalizeIndex } from "@ark/schema";
import { append, escapeToken, isArray, printable, stringAndSymbolicEntriesOf, throwParseError } from "@ark/util";
import { writeUnassignableDefaultValueMessage } from "./semantic/default.js";
export const parseObjectLiteral = (def, ctx) => {
    let spread;
    const structure = {};
    // We only allow a spread operator to be used as the first key in an object
    // because to match JS behavior any keys before the spread are overwritten
    // by the values in the target object, so there'd be no useful purpose in having it
    // anywhere except for the beginning.
    const parsedEntries = stringAndSymbolicEntriesOf(def).flatMap(entry => parseEntry(entry[0], entry[1], ctx));
    if (parsedEntries[0]?.kind === "spread") {
        // remove the spread entry so we can iterate over the remaining entries
        // expecting non-spread entries
        const spreadEntry = parsedEntries.shift();
        if (!spreadEntry.node.hasKind("intersection") ||
            !spreadEntry.node.structure) {
            return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.node.expression));
        }
        spread = spreadEntry.node.structure;
    }
    for (const entry of parsedEntries) {
        if (entry.kind === "spread")
            return throwParseError(nonLeadingSpreadError);
        if (entry.kind === "undeclared") {
            structure.undeclared = entry.behavior;
            continue;
        }
        structure[entry.kind] = append(structure[entry.kind], entry);
    }
    const structureNode = ctx.$.node("structure", structure);
    return ctx.$.schema({
        domain: "object",
        structure: spread?.merge(structureNode) ?? structureNode
    });
};
export const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;
export const nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
export const parseEntry = (key, value, ctx) => {
    const parsedKey = parseKey(key);
    if (parsedKey.kind === "+") {
        if (value !== "reject" && value !== "delete" && value !== "ignore")
            throwParseError(writeInvalidUndeclaredBehaviorMessage(value));
        return { kind: "undeclared", behavior: value };
    }
    if (parsedKey.kind === "...")
        return { kind: "spread", node: ctx.$.parse(value, ctx) };
    const parsedValue = isArray(value) && value[1] === "=" ?
        [ctx.$.parse(value[0], ctx), "=", value[2]]
        : ctx.$.parse(value, ctx, true);
    if (isArray(parsedValue)) {
        if (parsedKey.kind !== "required")
            throwParseError(invalidDefaultKeyKindMessage);
        const out = parsedValue[0].traverse(parsedValue[2]);
        if (out instanceof ArkErrors) {
            throwParseError(writeUnassignableDefaultValueMessage(printable(parsedKey.key), out.message));
        }
        return ctx.$.node("optional", {
            key: parsedKey.key,
            value: parsedValue[0],
            default: parsedValue[2]
        });
    }
    if (parsedKey.kind === "index") {
        const signature = ctx.$.parse(parsedKey.key, ctx);
        const normalized = normalizeIndex(signature, parsedValue, ctx.$);
        return (normalized.index ?
            normalized.required ?
                [normalized.index, ...normalized.required]
                : normalized.index
            : normalized.required ?? []);
    }
    return ctx.$.node(parsedKey.kind, {
        key: parsedKey.key,
        value: parsedValue
    });
};
// single quote use here is better for TypeScript's inlined error to avoid escapes
export const invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { value: 'number = 0' }`;
const parseKey = (key) => typeof key === "symbol" ? { kind: "required", key }
    : key.at(-1) === "?" ?
        key.at(-2) === escapeToken ?
            { kind: "required", key: `${key.slice(0, -2)}?` }
            : {
                kind: "optional",
                key: key.slice(0, -1)
            }
        : key[0] === "[" && key.at(-1) === "]" ?
            { kind: "index", key: key.slice(1, -1) }
            : key[0] === escapeToken && key[1] === "[" && key.at(-1) === "]" ?
                { kind: "required", key: key.slice(1) }
                : key === "..." ? { kind: key, key }
                    : key === "+" ? { kind: key, key }
                        : {
                            kind: "required",
                            key: key === "\\..." ? "..."
                                : key === "\\+" ? "+"
                                    : key
                        };
export const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;
