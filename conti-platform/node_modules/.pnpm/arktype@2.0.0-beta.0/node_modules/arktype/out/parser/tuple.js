import { jsObjects, makeRootAndArrayPropertiesMutable, tsKeywords } from "@ark/schema";
import { append, objectKindOrDomainOf, throwParseError } from "@ark/util";
import { writeMissingRightOperandMessage } from "./string/shift/operand/unenclosed.js";
export const parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);
export const parseTupleLiteral = (def, ctx) => {
    let sequences = [{}];
    let i = 0;
    while (i < def.length) {
        let spread = false;
        let optional = false;
        if (def[i] === "..." && i < def.length - 1) {
            spread = true;
            i++;
        }
        const element = ctx.$.parse(def[i], ctx);
        i++;
        if (def[i] === "?") {
            if (spread)
                return throwParseError(spreadOptionalMessage);
            optional = true;
            i++;
        }
        if (spread) {
            if (!element.extends(jsObjects.Array))
                return throwParseError(writeNonArraySpreadMessage(element.expression));
            // a spread must be distributed over branches e.g.:
            // def: [string, ...(number[] | [true, false])]
            // nodes: [string, ...number[]] | [string, true, false]
            sequences = sequences.flatMap(base => 
            // since appendElement mutates base, we have to shallow-ish clone it for each branch
            element.branches.map(branch => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch)));
        }
        else {
            sequences = sequences.map(base => appendElement(base, optional ? "optional" : "required", element));
        }
    }
    return ctx.$.internal.schema(sequences.map(sequence => ({
        proto: Array,
        sequence
    })));
};
const appendElement = (base, kind, element) => {
    switch (kind) {
        case "required":
            if (base.optionals)
                // e.g. [string?, number]
                return throwParseError(requiredPostOptionalMessage);
            if (base.variadic) {
                // e.g. [...string[], number]
                base.postfix = append(base.postfix, element);
            }
            else {
                // e.g. [string, number]
                base.prefix = append(base.prefix, element);
            }
            return base;
        case "optional":
            if (base.variadic)
                // e.g. [...string[], number?]
                return throwParseError(optionalPostVariadicMessage);
            // e.g. [string, number?]
            base.optionals = append(base.optionals, element);
            return base;
        case "variadic":
            // e.g. [...string[], number, ...string[]]
            if (base.postfix)
                throwParseError(multipleVariadicMesage);
            if (base.variadic) {
                if (!base.variadic.equals(element)) {
                    // e.g. [...string[], ...number[]]
                    throwParseError(multipleVariadicMesage);
                }
                // e.g. [...string[], ...string[]]
                // do nothing, second spread doesn't change the type
            }
            else {
                // e.g. [string, ...number[]]
                base.variadic = element.internal;
            }
            return base;
    }
};
const appendSpreadBranch = (base, branch) => {
    const spread = branch.firstReferenceOfKind("sequence");
    if (!spread) {
        // the only array with no sequence reference is unknown[]
        return appendElement(base, "variadic", tsKeywords.unknown.internal);
    }
    spread.prefix.forEach(node => appendElement(base, "required", node));
    spread.optionals.forEach(node => appendElement(base, "optional", node));
    spread.variadic && appendElement(base, "variadic", spread.variadic);
    spread.postfix.forEach(node => appendElement(base, "required", node));
    return base;
};
const maybeParseTupleExpression = (def, ctx) => {
    const tupleExpressionResult = isIndexZeroExpression(def) ? prefixParsers[def[0]](def, ctx)
        : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx)
            : undefined;
    return tupleExpressionResult;
};
export const writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;
export const multipleVariadicMesage = "A tuple may have at most one variadic element";
export const requiredPostOptionalMessage = "A required element may not follow an optional element";
export const optionalPostVariadicMessage = "An optional element may not follow a variadic element";
export const spreadOptionalMessage = "A spread element cannot be optional";
export const parseKeyOfTuple = (def, ctx) => ctx.$.parse(def[1], ctx).keyof();
const parseBranchTuple = (def, ctx) => {
    if (def[2] === undefined)
        return throwParseError(writeMissingRightOperandMessage(def[1], ""));
    const l = ctx.$.parse(def[0], ctx);
    const r = ctx.$.parse(def[2], ctx);
    return def[1] === "&" ? l.and(r) : l.or(r);
};
const parseArrayTuple = (def, ctx) => ctx.$.parse(def[0], ctx).array();
const isIndexOneExpression = (def) => indexOneParsers[def[1]] !== undefined;
export const parseMorphTuple = (def, ctx) => {
    if (typeof def[2] !== "function") {
        return throwParseError(writeMalformedFunctionalExpressionMessage("=>", def[2]));
    }
    // TODO: nested morphs?
    return ctx.$.parse(def[0], ctx).pipe(def[2]);
};
export const writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === ":" ? "Narrow" : "Morph"} expression requires a function following '${operator}' (was ${typeof value})`;
export const parseNarrowTuple = (def, ctx) => {
    if (typeof def[2] !== "function") {
        return throwParseError(writeMalformedFunctionalExpressionMessage(":", def[2]));
    }
    return ctx.$.parse(def[0], ctx).constrain("predicate", def[2]);
};
const parseAttributeTuple = (def, ctx) => ctx.$.parse(def[0], ctx).configureShallowDescendants(def[2]);
const indexOneParsers = {
    "|": parseBranchTuple,
    "&": parseBranchTuple,
    "[]": parseArrayTuple,
    ":": parseNarrowTuple,
    "=>": parseMorphTuple,
    "@": parseAttributeTuple
};
const prefixParsers = {
    keyof: parseKeyOfTuple,
    instanceof: (def, ctx) => {
        if (typeof def[1] !== "function") {
            return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));
        }
        const branches = def
            .slice(1)
            .map(ctor => typeof ctor === "function" ?
            ctx.$.node("proto", { proto: ctor })
            : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));
        return branches.length === 1 ?
            branches[0]
            : ctx.$.node("union", { branches });
    },
    "===": (def, ctx) => ctx.$.units(def.slice(1))
};
const isIndexZeroExpression = (def) => prefixParsers[def[0]] !== undefined;
export const writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;
