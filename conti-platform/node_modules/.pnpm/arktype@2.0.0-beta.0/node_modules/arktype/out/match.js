export const createMatchParser = ($) => (() => { }).bind($);
// const matchParser = (isRestricted: boolean) => {
// 	const handledCases: { when: RawRoot; then: Morph }[] = []
// 	let defaultCase: ((x: unknown) => unknown) | null = null
// 	const parser = {
// 		when: (when: unknown, then: Morph) => {
// 			handledCases.push({ when: $.parseRoot(when, {}), then })
// 			return parser
// 		},
// 		finalize: () => {
// 			// TODO: exhaustiveness checking
// 			const branches = handledCases.flatMap(({ when, then }) => {
// 				if (when.kind === "union") {
// 					return when.branches.map((branch) => ({
// 						in: branch,
// 						morph: then
// 					}))
// 				}
// 				if (when.kind === "morph") {
// 					return [{ in: when, morph: [when.morph, then] }]
// 				}
// 				return [{ in: when, morph: then }]
// 			})
// 			if (defaultCase) {
// 				branches.push({ in: keywordNodes.unknown, morph: defaultCase })
// 			}
// 			const matchers = $.node("union", {
// 				branches,
// 				ordered: true
// 			})
// 			return matchers.assert
// 		},
// 		orThrow: () => {
// 			// implicitly finalize, we don't need to do anything else because we throw either way
// 			return parser.finalize()
// 		},
// 		default: (x: unknown) => {
// 			if (x instanceof Function) {
// 				defaultCase = x as never
// 			} else {
// 				defaultCase = () => x
// 			}
// 			return parser.finalize()
// 		}
// 	}
// 	return parser
// }
// return Object.assign(() => matchParser(false), {
// 	only: () => matchParser(true)
// }) as never
