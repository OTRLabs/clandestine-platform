import type { GenericParamAst, GenericParamDef, GenericRoot, writeUnsatisfiedParameterConstraintMessage } from "@ark/schema";
import { type array, type Callable, type conform, type ErrorMessage, type keyError, type typeToString, type WhiteSpaceToken } from "@ark/util";
import type { inferDefinition } from "./parser/definition.js";
import type { inferAstRoot } from "./parser/semantic/infer.js";
import type { validateAst } from "./parser/semantic/validate.js";
import type { state, StaticState } from "./parser/string/reduce/static.js";
import { Scanner } from "./parser/string/shift/scanner.js";
import { parseUntilFinalizer } from "./parser/string/string.js";
import type { ParseContext } from "./scope.js";
import type { inferTypeRoot, Type, validateTypeRoot } from "./type.js";
export type ParameterString<params extends string = string> = `<${params}>`;
export type extractParams<s extends ParameterString> = s extends ParameterString<infer params> ? params : never;
export type validateParameterString<s extends ParameterString, $> = parseGenericParams<extractParams<s>, $> extends keyError<infer message> ? ErrorMessage<message> : s;
export type validateGenericArg<param extends GenericParamAst, def, $> = validateTypeRoot<def, $> extends infer result ? result extends ErrorMessage ? result : inferTypeRoot<def, $> extends param[1] ? def : ErrorMessage<writeUnsatisfiedParameterConstraintMessage<param[0], typeToString<param[1]>, "">> : never;
export type GenericInstantiation<params extends array<GenericParamAst> = array<GenericParamAst>, def = any, $ = any> = <const args>(...args: conform<args, {
    [i in keyof params]: validateGenericArg<params[i], args[i & keyof args], $>;
}>) => Type<inferDefinition<def, $, bindGenericArgs<params, $, args>>, $>;
type bindGenericArgs<params extends array<GenericParamAst>, $, args> = {
    [i in keyof params & `${number}` as params[i][0]]: inferTypeRoot<args[i & keyof args], $>;
};
export type baseGenericArgs<params extends array<GenericParamAst>> = {
    [i in keyof params & `${number}` as params[i][0]]: params[i][1];
};
export interface Generic<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}> extends Callable<GenericInstantiation<params, bodyDef, $>>, GenericRoot<params, bodyDef, $> {
}
export type GenericDeclaration<name extends string = string, params extends ParameterString = ParameterString> = `${name}${params}`;
export type parseValidGenericParams<def extends ParameterString, $> = conform<parseGenericParams<extractParams<def>, $>, array<GenericParamAst>>;
export declare const emptyGenericParameterMessage = "An empty string is not a valid generic parameter name";
export type emptyGenericParameterMessage = typeof emptyGenericParameterMessage;
export declare const parseGenericParams: (def: string, ctx: ParseContext) => array<GenericParamDef>;
export type parseGenericParams<def extends string, $> = parseNextNameChar<Scanner.skipWhitespace<def>, "", [
], $>;
declare const paramsTerminators: {
    ",": boolean;
    ":": boolean;
    " ": true;
    "\n": true;
    "\t": true;
};
type ParamsTerminator = keyof typeof paramsTerminators;
declare const parseName: (scanner: Scanner, result: GenericParamDef[], ctx: ParseContext) => GenericParamDef[];
type parseName<unscanned extends string, result extends array<GenericParamAst>, $> = parseNextNameChar<Scanner.skipWhitespace<unscanned>, "", result, $>;
type parseNextNameChar<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = unscanned extends `${infer lookahead}${infer nextUnscanned}` ? lookahead extends ParamsTerminator ? name extends "" ? keyError<emptyGenericParameterMessage> : lookahead extends "," ? parseName<nextUnscanned, [...result, [name, unknown]], $> : lookahead extends ":" | WhiteSpaceToken ? _parseOptionalConstraint<unscanned, name, result, $> : never : parseNextNameChar<nextUnscanned, `${name}${lookahead}`, result, $> : name extends "" ? result : [...result, [name, unknown]];
declare const extendsToken = "extends ";
type ConstrainingToken = ":" | typeof extendsToken;
declare const _parseOptionalConstraint: (scanner: Scanner, name: string, result: GenericParamDef[], ctx: ParseContext) => GenericParamDef[];
type _parseOptionalConstraint<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = Scanner.skipWhitespace<unscanned> extends (`${ConstrainingToken}${infer nextUnscanned}`) ? parseUntilFinalizer<state.initialize<nextUnscanned>, $, {}> extends (infer finalArgState extends StaticState) ? validateAst<finalArgState["root"], $, {}> extends (ErrorMessage<infer message>) ? keyError<message> : parseName<finalArgState["unscanned"], [
    ...result,
    [name, inferAstRoot<finalArgState["root"], $, {}>]
], $> : never : parseName<Scanner.skipWhitespace<unscanned> extends `,${infer nextUnscanned}` ? nextUnscanned : unscanned, [
    ...result,
    [name, unknown]
], $>;
export {};
