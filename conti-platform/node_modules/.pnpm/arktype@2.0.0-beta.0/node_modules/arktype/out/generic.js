import { throwParseError, whiteSpaceTokens } from "@ark/util";
import { DynamicState } from "./parser/string/reduce/dynamic.js";
import { Scanner } from "./parser/string/shift/scanner.js";
import { parseUntilFinalizer } from "./parser/string/string.js";
export const emptyGenericParameterMessage = "An empty string is not a valid generic parameter name";
export const parseGenericParams = (def, ctx) => parseName(new Scanner(def), [], ctx);
const paramsTerminators = { ...whiteSpaceTokens, ",": true, ":": true };
const parseName = (scanner, result, ctx) => {
    scanner.shiftUntilNonWhitespace();
    const name = scanner.shiftUntilNextTerminator();
    if (name === "") {
        // if we've reached the end of the string and have parsed at least one
        // param, return the valid result
        if (scanner.lookahead === "" && result.length)
            return result;
        return throwParseError(emptyGenericParameterMessage);
    }
    scanner.shiftUntilNonWhitespace();
    return _parseOptionalConstraint(scanner, name, result, ctx);
};
const extendsToken = "extends ";
const _parseOptionalConstraint = (scanner, name, result, ctx) => {
    scanner.shiftUntilNonWhitespace();
    if (scanner.lookahead === ":")
        scanner.shift();
    else if (scanner.unscanned.startsWith(extendsToken))
        scanner.jumpForward(extendsToken.length);
    else {
        // if we don't have a contraining token here, return now so we can
        // assume in the rest of the function body we do have a constraint
        if (scanner.lookahead === ",")
            scanner.shift();
        result.push(name);
        return parseName(scanner, result, ctx);
    }
    const s = parseUntilFinalizer(new DynamicState(scanner, ctx, false));
    result.push([name, s.root]);
    return parseName(scanner, result, ctx);
};
